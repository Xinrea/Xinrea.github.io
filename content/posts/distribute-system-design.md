---
title: 分布式系统设计思路总览
date: 2023-06-24
draft: true
tags: ["Distribute System", "Design"]
showtoc: true
---

## CAP 定理

CAP 原则又称 CAP 定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。

显然分区容错性 P 是必须要满足的，因为在分布式系统中网络是不可靠的，这意味着系统很可能会被分割成多个区域（也等效于节点失效，因为客观上无法分辨是网络原因还是节点原因）。如果此时不能保证分区容错性，那么也就是所一旦发生分区（或者说节点失效），分布式系统就无法正常工作了；由于分布式系统中含有许多节点，这会导致系统的故障率远远大于单体，这显然是不能接受的，与使用分布式系统的初衷背道而驰。

因此在满足 P 的前提下，也就是说当节点失效时，C 和 A 之间的取舍就成为了分布式系统设计中的核心问题。在实际的分布式系统中，我们看到的所有设计都是围绕这两点来进行的。

## 从单体到多体

假设我们有一个服务 A 运行在单个节点上，它的功能是 `resp = f(req)`。这个服务十分重要，我们希望它能够 7x24 小时运行，不间断地提供服务。那么我们就需要考虑如何保证这个服务的可用性。

如果服务 A 是无状态的，也就是说服务 A 的响应 `resp` 只取决于 `req`，而与之前的请求无关，那么我们可以通过复制的方式来保证服务的可用性。我们可以在任意多的节点上运行服务 A，然后将请求以任意形式分发到可用的节点上，从而保证服务的可用性。这类无状态服务处理起来比较简单，因此在微服务拆分时，我们尽量将服务拆分成无状态的服务，这样可以大大降低系统的复杂度。

但是，在实际中比较重要的服务往往是有状态的，也就是说服务 A 的响应 `resp` 不仅取决于 `req`，还取决于之前的请求。

### 1. 备份（Master-Slave/Leader-Follower/Primary-Replica）

针对有状态服务，最简单的方法就是备份，我们可以在另一个节点上运行一个服务 B，它的功能也是 `resp = f(req)`。当请求到达时，我们将请求同时发送到 A 和 B，然后将 A 或者 B 的响应返回给客户端。这样，B 节点的状态与 A 节点一致，当 A 节点发生故障时，我们可以切换到 B 节点，让其接替服务。我们称 A、B 这些节点组成了一个集群。

想想这样一个场景，请求到达集群后，由于网络原因（或者故障，集群视角无法区分），其中一个节点没有响应这个请求，那么这意味着这个节点的状态与其他节点不一致，这时我们应该怎么办呢？

#### 1.1 拥抱一致性

保证强一致性（线性一致性）可以想到以下几种处理方法

- 对外响应处理失败，那么对于集群内的 N 个节点，一旦有一个节点出现错误，其他所有节点都要撤销操作，保证与失败的节点状态一致
- 不断重试，最终对外响应处理成功。但是这样会导致请求的响应时间变长，很有可能请求永远也不会成功
- 对外响应处理成功，剔除故障节点，将故障节点定义到一致性范围之外。这样做的问题是，如果故障节点恢复了，那么它的状态就会与其他节点不一致，一致性要求集群内节点必须与集群内其他节点状态一致，这意味着故障节点永远无法恢复；如果要加入或者恢复节点，都要停止对外服务，等待集群内所有节点状态一致再对外开放。遗憾的是，节点故障在分布式系统中是常态，这样做显然是不可行的

可见为了保证一致性，我们必须要牺牲可用性，这与 CAP 原则是一致的。

#### 1.2 拥抱可用性

如果我们选择可用性，那么我们可以采取以下处理方法

- 如果部分节点处理成功，那么就对外响应处理成功

这里的 `部分` 可以是一个，可以是大部分，可以是权重最高的几个，也可以是随机的几个，可以自由选择合适的策略。

这样做的问题是，后续请求发送到状态不一致的节点上时，处理很可能是错误的；好处是可用性大大提升，至少请求都及时处理了。

虽然能够完成请求，但是如果对请求的处理都是错的，那么可用性再高也没有意义；还好这里 `错` 的定义还有可商量的余地，使得我们可以在一致性和可用性之间做出权衡。

#### 1.3 拥抱最终一致性

最终一致性是指，在没有新的请求时，集群内的节点最终会达到一致状态，显然这里的时间差越短越好。实际上，可以结合 1.1 和 1.2 的方法来实现这一点。

回顾以下两种方法：

- [一致性] 对外响应处理成功，剔除故障节点，将故障节点定义到一致性范围之外
- [可用性] 如果部分节点处理成功，那么就对外响应处理成功

一致性方面，我们定义符合最终一致性的节点集合为 E，其中的强一致性节点组成集合 C；集群的状态为其中状态最新的节点状态。根据请求的类别，我们可以将请求分为两类：

- 强一致性请求：例如涉及到写操作的请求，这类请求只能发送到强一致性节点集合 C 上，原因是：写操作需要改变集群的状态，将集群看作状态机，初始状态 S<sub>k</sub> 在收到操作 W<sub>j</sub> 后，状态改变为 S<sub>k+1</sub>；同理要让状态最终一致，那么要求 W<sub>j</sub> 必须发送到状态为 S<sub>k</sub> 的节点上，这样才能保证集群最终状态一致；即涉及到状态改变的操作，只能发送到 C 上
- 最终一致性请求：首先这类请求不涉及集群状态变化，可以发送到最终一致性节点集合 E 上（C 属于 E）；其次读取到旧数据，不在 `错` 的定义中，可以容忍

我们来看看强一致性节点集合 C 是怎样的：

对于强一致性节点集合 C，从 1.1 中得知，C 中元素越多，集群处理强一致性请求的可用性越低；

在可用性上，考虑实际情况，由于集群内节点是动态变化的，如果在客户端实现请求结果判断策略，那么客户端将会非常复杂，而且不可靠。如果在集群内实现请求结果判断策略，那么有两种方式：

- 实现一个中间件，将请求转发到集群内的节点，由中间件来收集结果，判断最终响应的结果。这样做的问题是，中间件成为了单点，如果中间件发生故障，那么整个集群都无法对外提供服务。于是需要面多加水，水多加面，中间件也要做集群化。

#### 1.1 如何切换

切换的方法有很多种，最简单的方法就是人工干预，当 A 节点发生故障时，我们手动将请求切换到 B 节点。这种方法的缺点是，当 A 节点发生故障时，服务的可用性会有一段时间的下降，直到人工干预完成。这段时间的长短取决于人工干预的速度，而人工干预的速度又取决于人的反应速度，这是一个不确定的量，因此这种方法并不可靠。
