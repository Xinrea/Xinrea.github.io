<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>数据系统事务的简单探讨 | 杏仁儿的博客</title>
<meta name=keywords content="数据系统,数据库,笔记,事务"><meta name=description content="前言
为了降低应用程序开发人员的心智负担，数据系统提供事务这一机制来简化各种各样的常见问题。事务将应用程序的多个读写操作捆绑在一起，称为一个逻辑操作单元。"><meta name=author content><link rel=canonical href=https://xinrea.cn/posts/transaction-in-data-system/><link crossorigin=anonymous href=/assets/css/stylesheet.c59fd7dc73cc74453a3eb2f12a5ae4a153a313be611ddfb44f5c98375c9c2039.css integrity="sha256-xZ/X3HPMdEU6PrLxKlrkoVOjE75hHd+0T1yYN1ycIDk=" rel="preload stylesheet" as=style><link rel=icon href=https://xinrea.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xinrea.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://xinrea.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://xinrea.cn/apple-touch-icon.png><link rel=mask-icon href=https://xinrea.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://xinrea.cn/posts/transaction-in-data-system/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css integrity=sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js integrity=sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:url" content="https://xinrea.cn/posts/transaction-in-data-system/"><meta property="og:site_name" content="杏仁儿的博客"><meta property="og:title" content="数据系统事务的简单探讨"><meta property="og:description" content="前言 为了降低应用程序开发人员的心智负担，数据系统提供事务这一机制来简化各种各样的常见问题。事务将应用程序的多个读写操作捆绑在一起，称为一个逻辑操作单元。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-25T00:00:00+00:00"><meta property="article:modified_time" content="2025-03-17T17:24:04+08:00"><meta property="article:tag" content="数据系统"><meta property="article:tag" content="数据库"><meta property="article:tag" content="笔记"><meta property="article:tag" content="事务"><meta name=twitter:card content="summary"><meta name=twitter:title content="数据系统事务的简单探讨"><meta name=twitter:description content="前言
为了降低应用程序开发人员的心智负担，数据系统提供事务这一机制来简化各种各样的常见问题。事务将应用程序的多个读写操作捆绑在一起，称为一个逻辑操作单元。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://xinrea.cn/posts/"},{"@type":"ListItem","position":2,"name":"数据系统事务的简单探讨","item":"https://xinrea.cn/posts/transaction-in-data-system/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"数据系统事务的简单探讨","name":"数据系统事务的简单探讨","description":"前言 为了降低应用程序开发人员的心智负担，数据系统提供事务这一机制来简化各种各样的常见问题。事务将应用程序的多个读写操作捆绑在一起，称为一个逻辑操作单元。\n","keywords":["数据系统","数据库","笔记","事务"],"articleBody":"前言 为了降低应用程序开发人员的心智负担，数据系统提供事务这一机制来简化各种各样的常见问题。事务将应用程序的多个读写操作捆绑在一起，称为一个逻辑操作单元。\n执行事务只有两种结果，要么成功要么失败，且失败无副作用，不会产生任何修改；因此，如果失败，那么应用程序可以放心重试。有了事务，应用程序可以不用考虑某些内部潜在的错误以及复杂的并发性问题，这些都由数据库自己来处理，因此又被称之为安全性保证。\n一、理解事务 我们知道事务是数据库提供的安全性保证，用于屏蔽数据库内内部的错误以及并发问题，那么这个安全性保证具体包含哪些方面呢？这便是我们常说的 ACID。\n1.1 ACID ACID，即 Atomicity、Consistency、Isolation 和 Durability。显然，各个数据库能提供的安全性保证是不一样的，因此 ACID 在各个数据库上的表现也会有所区别，但是还是有比较笼统的概念的。\n1.1.1 原子性 Atomicity 想象这样一个场景，客户端发起了包含多个写操作的请求，而这个请求执行到一半时因为各种原因失败了（数据库错误/执行时判断失败），此时客户端该如何继续变成了问题；为了让客户端不用管理请求的执行进度，我们将其包装为一个整体的“原子操作”：如果执行失败，那么数据库必须丢弃或者撤销那些局部完成的修改。\n通过原子性保证，如果事务中止，应用程序可以确定没有实质发生任何更改，所以可以安全地重试（因此又被称为可中止性）。\n1.1.2 一致性 Consistency ACID 中的一致性指的是数据层面状态的一致性，例如数据库中 A 的值一定是 B 的值的两倍，那么从满足该一致性的状态开始，执行一个合法的事务后，得到的结果也应满足这个约束。显然，数据之中的约束是应用层定义的，数据库通常只能提供有限的约束工具，例如外键约束和唯一性约束，因此一致性通常是由应用程序本身来维护的。\n1.1.3 隔离性 Isolation 当多个客户端同时使用数据库时，如果访问同一记录，那么便会产生并发问题。为了让应用程序无需考虑并发竞争，数据库提供隔离性保证，这意味着应用执行事务时，从其视角来看所有的事务都是按照顺序在执行的，而数据库也要使用各种机制，确保这些事务在执行完成后所得的结果与顺序执行结果一致，这样才能符合应用的预期；实际中由于性能问题，数据库很少能够提供这样严格的隔离性，因此各个数据库提供的隔离性可能不同。\n1.1.4 持久性 Durability 持久性是大部分数据存储系统的基础保证，即数据写入（事务提交）完成后，不管发生什么情况，写入的数据都不应丢失。显然，持久性也是有限，不同数据库所提供的持久性保证都不一样：分布式数据库与单机数据库相比，提供的持久性通常会更好。\n综上所述，原子性保证对于各类数据库来说比较统一；一致性保证与数据库提供的工具有关，且责任在应用层；隔离性保证太过绝对，在各类数据库中都不太一样；持久性保证也很模糊，各类数据库或者说实际情况下都不一样。总而言之，也就原子性比较统一，其他概念在实际实现中都是比较模糊的。\n1.2 单对象写入与多对象事务 在前文提到了 ACID 的安全性保证，在数据库设计中，通常只用关心原子性和隔离性。对于持久性，这是存储系统的基石，无需额外讨论；对于一致性，如果应用提供正确的操作，而数据库保证操作的原子性和隔离性，那么便能保证一致性，因此也不单独讨论，因此我们主要聚焦原子性与隔离性在数据库中的设计和实现。\n接下来我们简单思考一下事务的一些注意事项。\n1.2.1 单对象写入 我们知道，最底层的原子性保证来源于 CPU 的设计，且其只保证了极其有限的操作；对于数据库存储的对象来说，那就更不存在原子性了，因此就算是单对象，其原子性和隔离性也不是天然的：例如数据库写入 100KB 的单对象时，在写的中途也要保证不被读到部分更新的数据（隔离性）；在写的中途失败时，写造成的修改也要能够撤销（原子性）。如果没有单对象的原子性和隔离性保证，那么就更别谈多对象的处理了。\n因此存储引擎在设计时便考虑了单对象的原子性和隔离性的支持，例如使用日志来实现原子性（可恢复可撤销），而使用锁来实现对象的隔离性。因此在我们通常的讨论中，单对象的原子性和隔离性太过基础，我们默认其是底层提供的基础保证，事务（多操作聚合）是在此基础之上的讨论，这也是为什么这部分标题并未称为“单对象事务”。\n1.2.2 多对象事务 在分布式数据库中，多对象事务还是有一定复杂度的，原因在于这些对象可能由于分区存在于不同的子数据库实例中。多对象事务对于一致性的保证有重要的帮助作用，例如同步更新的二级索引、外键引用的有效性、多文档同时更新等。\n1.2.3 处理错误与中止 前文我们提到事务提供了失败之后可以安全重试的保障，因此对于错误和中止，我们尽量尝试重试，但重试机制还有许多问题需要注意：\n事务执行成功，但应用认为执行失败（各种原因导致未收到成功确认），此时产生的重试可能出现问题：可以提供事务 id 以确保已提交的事务不会重复执行； 外因中止，例如系统超负荷运行导致事务执行失败，反复重试反而会加重系统负担：设定重试次数上限； 事务本身操作违反约束导致的失败：应用应调整操作内容而不是继续重试； 事务只能保证数据库内无副作用，如果有机制与数据库外操作相关，重试可能触发数据库外的副作用，例如更新时发送邮件，重试可能导致多次发送：涉及到多系统事务，可以使用两阶段提交； 本应进行重试的应用失效，导致重试操作丢失，可能导致数据丢失：应用也要具有持久化的能力。 二、弱隔离级别 接下来我们探讨事务的隔离性，由于这一部分比较复杂，因此单独进行说明。\n前文提到隔离性是为了解决数据库的并发访问问题而抽象出的概念，严格的隔离性使得并发操作执行的结果，与其按照顺序执行的结果一致，这意味着在应用执行事务时，无需关心并发的问题。然而在实际中，这种串行化的隔离性严重限制了数据库的性能，因此通常数据库提供较弱一些的隔离性保证，或是提供一些可选的隔离性配置。\n在非串行化隔离下，总会出现各种各样的问题，我们将问题归纳为以下几种进行标记，并讨论各种隔离级别对这些常见问题的解决：\nA脏读 B脏写 C读倾斜 D写倾斜 E幻读 F更新丢失 2.1 读-提交 读-提交通常是最基础的隔离级别，它只提供两个保证：\n解决 A脏读：读数据库时，只能看到已成功提交的数据； 解决 B脏写：写数据库时，只会覆盖已成功提交的数据。 关于为什么要防止脏读，原因很明显就不再赘述；我们重点关注脏写的问题：\n当有两个事务同时在执行时，前一个事务的写还未提交，而后一个事务想要写数据，如果在未提交的数据上覆盖，则称为脏写，最简单的处理方式是等待直到待写的数据被提交再进行。\n脏写会带来什么问题呢，想象这样一个场景，用户提交的事务需要修改 A、B 两处数据，同时有两个用户提交了事务在执行：\n最终导致 A 为用户 2 的数据，B 为用户 1 的数据；脏写会导致不同事务的并发写入最终混杂在一起。\n2.1.1 读-提交的实现 数据库要实现读-提交，那么就要解决 A脏读 和 B脏写。\nA脏读 的解决 一种方式是直接加读写锁，一旦数据正在被写入，则排斥读操作，但是这会导致只读事务的执行受阻，严重影响只读事务的响应延迟；因此大多数数据库使用另一种方式来实现：对于每个待更新的对象，数据库都会维护其旧值和当前持锁事务将要设置的新值两个版本，在这个事务提交之前，其他事务读取到的都是旧值，也就防止了 A脏读。\nB脏写 的解决 显然对于并发写，最简单的方法便是加写锁，数据库通常采用行级锁来防止 B脏写。\n2.2 快照级别隔离与可重复读 显然读-提交级别还有解决不了的问题，那便是 C读倾斜。考虑以下场景，用户正在使用事务 T1 查询两个账户的总余额，而后台有个程序正在用事务 T2 执行两个账户之间的转账：\nT2 更新了两个账户的余额，完成转账操作，两个账户的总额不变仍是 200；用户在查询 Account1 的余额时，由于 T2 还未提交，因此读取到的是读-提交保证的旧值 100，当其查询 Account2 的余额时，由于 T2 已经提交，因此读取到的是新值 200，符合读-提交的隔离性保证，但因此得出的总余额结果却是 300，这便是 C读倾斜，又可称为 C不可重复度读。\nC读倾斜 产生的原因是同一个事务内读取到了两个版本的数据，旧的 Account1 和新的 Account2，倘若 T1 在最后添加一个 Account1 的余额查询操作，便会发现前后两次查询操作结果不一致，这便是 C不可重复度读 这个名称的由来。\n在以下场景中 C读倾斜 很有可能发生：\n备份场景：在备份过程中数据库数据在不断更新，备份的数据可能新旧混杂，一致性被破坏； 分析查询与完整性检查：由于数据在不断更新，这类查询和检查无法实现。 C读倾斜 的解决 显然，事务在执行过程中应当读取一致的数据（同一个版本的数据），这为我们指明了版本控制这一思路。在读-提交中，为了解决 A脏读，我们维护了数据的新旧值，当写事务为提交时读旧值，提交后读新值；为了解决 C读倾斜，我们要更进一步，就算写事务已经提交，其旧值甚至更旧的值仍可能需要维护：有之前正在执行的事务需要读这个数据。\n这意味着旧值不再是一个临时维护的值，而是跟新值一样，是长期需要管理的值；考虑到多个正在进行的事务可能会在不同的时间点查看数据库状态，所以数据库保留了对象多个不同的提交版本，这种技术因此也被称为多版本并发控制（Multi-Version Concurrency Control，MVCC）。\n事务执行在数据库完整的一个版本快照上，因此又被称之为快照级别隔离。当事务执行时，首先赋予一个唯一的、单调递增的事务 ID。每当事务向数据库内写入新内容是，所写的数据都会被标记写入者的事务 ID。\n那么对于一个事务 Tk，其能访问的数据是哪些版本呢？考虑下图的场景：\n对于 事务 Tk 开始时：\n还未提交的事务 Ta：显然这部分数据不可见； 中止的事务：由原子性保证这部分数据不可见； 晚于 Tk 的事务：显然不可见； 其他所有写入都应可见。 简单来说，只有事务开始时，数据库内已提交的事务才可见；事务开始后数据的可见性不再变化，形成了“快照”。\n多版本看起来并不复杂，但是要考虑其与数据库其他功能的兼容性，最重要的便是索引与快照级别隔离兼容的处理。\n索引与快照级别隔离 显然，在多版本数据库中，索引指向的数据有多个版本，最简单的方法便是索引指向所有版本，找出后再根据版本进行过滤；对于使用 B-Tree 的数据库，还可以使用写时复制的技术：\n如图所示，在 B-Tree 中想要修改 D，写入新数据 D’，那么要修改其对应父节点中存储的指针，因此父节点也创建了新版本，同理一直往上，直到创建了新版本的根节点 R’。其中不受影响的 B、C 节点及其子节点，在两个树中被共享。\n在每个写入事务开始时创建一个新的版本树，然后在整个事务流程过程中都使用这个新树的根节点开始查找，无论是数据还是索引都是如此；在这个树中所能见到的数据都是这个事务所应该能看到的数据，因此无需进行版本过滤；显然，这些根节点就形成一系列快照。\n2.3 防止 F更新丢失 就算是快照级别隔离也存在问题没有解决，F更新丢失便是其中一个。F更新丢失发生在 read-modify-write 这样的操作流程里，这个流程十分常见，比如：\n计数器：一定是要读取当前值再进行修改 修改复杂对象的一部分 广义来说，F更新丢失也会出现在其他场景，比如 有关数据系统的一些简要笔记 中的写冲突部分，当两个用户并发写同一个位置的数据时，便会形成写冲突，某些解决方案会最终采用定义上最新的数据，造成F更新丢失。\n原子写操作 读-修改-写产生的问题不是新问题，此事在经典多线程程序中亦有记载，可以使用原子操作来解决。在多数关系数据库中，简单的 UPDATE 都是并发安全的，是数据库提供的原子更新操作。要实现原子操作，通常采取对读取对象加独占锁的方式来实现，这种技术有时被称为游标稳定性；另一种方式是强制所有的原子操作都在指定的单线程上执行，根据使用场景，这种方式的效率也并不低。\n显式加锁 由于原子操作提供的保证有限，无法适应一些应用层逻辑上的安全保证，因此数据库都提供了常见的锁机制。例如：SELECT … FOR UPDATE，将满足指定条件的行都选出来，标记为 FOR UPDATE，即加上锁。\n如果数据库没有提供前文提到的原子写操作，用锁也可以很容易自己实现。\n自动检测更新丢失 前文提到的两种方式都是把操作串行化来避免F更新丢失，是一种悲观的策略；实际上，操作并行化，并非一定会出现F更新丢失，例如一个操作在读-修改-写，另一个操作在读-修改-写到别的位置，实际上并未冲突。因此可以采取一些乐观的策略，比如自动检测更新丢失。\n借助于多版本，我们可以很简单的检测出F更新丢失：当事务在读-修改-写时，最后写回时发现值的版本更新了，那么说明遇到了冲突，如果写入便会发生F更新丢失；当检测到后，可以回退事务，并使用原子的更新操作来重新执行。\n原子比较和设置 熟悉多线程编程便会知道，CAS 原子指令很有用，其实可以看成是弱化版的自动F更新丢失检测。自动更新丢失检测是使用版本号来判断，而 CAS 是根据值来判断。\n如果数据库提供了原子性的 CAS 指令，要谨慎使用，原因是多版本技术下，CAS 不一定能检测到版本变化，要注意其适用范围。\n冲突解决与复制 前文提到的方式实际上都是避免冲突发生，从而避免更新丢失的，然而在多副本数据库中，需要加锁的部分可能横跨多个节点，锁的实现需要考虑很多额外的东西；在多主或者无主系统中，甚至无法使用锁，因此只能在冲突发生后来进行解决，可以参照有关数据系统的一些简要笔记写冲突部分。\n2.4 D写倾斜与E幻读 2.5 串行化 严格串行执行事务 两阶段加锁 2PL 可串行化的快照隔离 ","wordCount":"5344","inLanguage":"en","datePublished":"2025-02-25T00:00:00Z","dateModified":"2025-03-17T17:24:04+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://xinrea.cn/posts/transaction-in-data-system/"},"publisher":{"@type":"Organization","name":"杏仁儿的博客","logo":{"@type":"ImageObject","url":"https://xinrea.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xinrea.cn/ accesskey=h title="杏仁儿的博客 (Alt + H)">杏仁儿的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xinrea.cn/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://xinrea.cn/tags title=Tags><span>Tags</span></a></li><li><a href=https://xinrea.cn/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://xinrea.cn/projects title=Projects><span>Projects</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://xinrea.cn/>Home</a>&nbsp;»&nbsp;<a href=https://xinrea.cn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">数据系统事务的简单探讨
<span class=entry-hint title=Draft><svg height="35" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-meta><span title='2025-02-25 00:00:00 +0000 UTC'>February 25, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;5344 words&nbsp;|&nbsp;<a href=https://github.com/Xinrea/Xinrea.github.io/tree/main/content/posts/transaction-in-data-system.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e4%b8%80%e7%90%86%e8%a7%a3%e4%ba%8b%e5%8a%a1 aria-label=一、理解事务>一、理解事务</a><ul><li><a href=#11-acid aria-label="1.1 ACID">1.1 ACID</a><ul><li><a href=#111-%e5%8e%9f%e5%ad%90%e6%80%a7-atomicity aria-label="1.1.1 原子性 Atomicity">1.1.1 原子性 Atomicity</a></li><li><a href=#112-%e4%b8%80%e8%87%b4%e6%80%a7-consistency aria-label="1.1.2 一致性 Consistency">1.1.2 一致性 Consistency</a></li><li><a href=#113-%e9%9a%94%e7%a6%bb%e6%80%a7-isolation aria-label="1.1.3 隔离性 Isolation">1.1.3 隔离性 Isolation</a></li><li><a href=#114-%e6%8c%81%e4%b9%85%e6%80%a7-durability aria-label="1.1.4 持久性 Durability">1.1.4 持久性 Durability</a></li></ul></li><li><a href=#12-%e5%8d%95%e5%af%b9%e8%b1%a1%e5%86%99%e5%85%a5%e4%b8%8e%e5%a4%9a%e5%af%b9%e8%b1%a1%e4%ba%8b%e5%8a%a1 aria-label="1.2 单对象写入与多对象事务">1.2 单对象写入与多对象事务</a><ul><li><a href=#121-%e5%8d%95%e5%af%b9%e8%b1%a1%e5%86%99%e5%85%a5 aria-label="1.2.1 单对象写入">1.2.1 单对象写入</a></li><li><a href=#122-%e5%a4%9a%e5%af%b9%e8%b1%a1%e4%ba%8b%e5%8a%a1 aria-label="1.2.2 多对象事务">1.2.2 多对象事务</a></li><li><a href=#123-%e5%a4%84%e7%90%86%e9%94%99%e8%af%af%e4%b8%8e%e4%b8%ad%e6%ad%a2 aria-label="1.2.3 处理错误与中止">1.2.3 处理错误与中止</a></li></ul></li></ul></li><li><a href=#%e4%ba%8c%e5%bc%b1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab aria-label=二、弱隔离级别>二、弱隔离级别</a><ul><li><a href=#21-%e8%af%bb-%e6%8f%90%e4%ba%a4 aria-label="2.1 读-提交">2.1 读-提交</a><ul><li><a href=#211-%e8%af%bb-%e6%8f%90%e4%ba%a4%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="2.1.1 读-提交的实现">2.1.1 读-提交的实现</a><ul><li><a href=#%e7%9a%84%e8%a7%a3%e5%86%b3 aria-label="A脏读 的解决">A脏读 的解决</a></li><li><a href=#%e7%9a%84%e8%a7%a3%e5%86%b3-1 aria-label="B脏写 的解决">B脏写 的解决</a></li></ul></li></ul></li><li><a href=#22-%e5%bf%ab%e7%85%a7%e7%ba%a7%e5%88%ab%e9%9a%94%e7%a6%bb%e4%b8%8e%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb aria-label="2.2 快照级别隔离与可重复读">2.2 快照级别隔离与可重复读</a><ul><li><a href=#%e7%9a%84%e8%a7%a3%e5%86%b3-2 aria-label="C读倾斜 的解决">C读倾斜 的解决</a></li><li><a href=#%e7%b4%a2%e5%bc%95%e4%b8%8e%e5%bf%ab%e7%85%a7%e7%ba%a7%e5%88%ab%e9%9a%94%e7%a6%bb aria-label=索引与快照级别隔离>索引与快照级别隔离</a></li></ul></li><li><a href=#23-%e9%98%b2%e6%ad%a2-f%e6%9b%b4%e6%96%b0%e4%b8%a2%e5%a4%b1 aria-label="2.3 防止 F更新丢失">2.3 防止 F更新丢失</a><ul><li><a href=#%e5%8e%9f%e5%ad%90%e5%86%99%e6%93%8d%e4%bd%9c aria-label=原子写操作>原子写操作</a></li><li><a href=#%e6%98%be%e5%bc%8f%e5%8a%a0%e9%94%81 aria-label=显式加锁>显式加锁</a></li><li><a href=#%e8%87%aa%e5%8a%a8%e6%a3%80%e6%b5%8b%e6%9b%b4%e6%96%b0%e4%b8%a2%e5%a4%b1 aria-label=自动检测更新丢失>自动检测更新丢失</a></li><li><a href=#%e5%8e%9f%e5%ad%90%e6%af%94%e8%be%83%e5%92%8c%e8%ae%be%e7%bd%ae aria-label=原子比较和设置>原子比较和设置</a></li><li><a href=#%e5%86%b2%e7%aa%81%e8%a7%a3%e5%86%b3%e4%b8%8e%e5%a4%8d%e5%88%b6 aria-label=冲突解决与复制>冲突解决与复制</a></li></ul></li><li><a href=#24-d%e5%86%99%e5%80%be%e6%96%9c%e4%b8%8ee%e5%b9%bb%e8%af%bb aria-label="2.4 D写倾斜与E幻读">2.4 D写倾斜与E幻读</a></li><li><a href=#25-%e4%b8%b2%e8%a1%8c%e5%8c%96 aria-label="2.5 串行化">2.5 串行化</a><ul><li><a href=#%e4%b8%a5%e6%a0%bc%e4%b8%b2%e8%a1%8c%e6%89%a7%e8%a1%8c%e4%ba%8b%e5%8a%a1 aria-label=严格串行执行事务>严格串行执行事务</a></li><li><a href=#%e4%b8%a4%e9%98%b6%e6%ae%b5%e5%8a%a0%e9%94%81-2pl aria-label="两阶段加锁 2PL">两阶段加锁 2PL</a></li><li><a href=#%e5%8f%af%e4%b8%b2%e8%a1%8c%e5%8c%96%e7%9a%84%e5%bf%ab%e7%85%a7%e9%9a%94%e7%a6%bb aria-label=可串行化的快照隔离>可串行化的快照隔离</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>为了降低应用程序开发人员的心智负担，数据系统提供<strong>事务</strong>这一机制来简化各种各样的常见问题。事务将应用程序的多个读写操作捆绑在一起，称为一个逻辑操作单元。</p><p>执行事务只有两种结果，要么成功要么失败，且失败无副作用，不会产生任何修改；因此，如果失败，那么应用程序可以放心重试。有了事务，应用程序可以不用考虑某些内部潜在的错误以及复杂的并发性问题，这些都由数据库自己来处理，因此又被称之为安全性保证。</p><h2 id=一理解事务>一、理解事务<a hidden class=anchor aria-hidden=true href=#一理解事务>#</a></h2><p>我们知道事务是数据库提供的安全性保证，用于屏蔽数据库内内部的错误以及并发问题，那么这个安全性保证具体包含哪些方面呢？这便是我们常说的 ACID。</p><h3 id=11-acid>1.1 ACID<a hidden class=anchor aria-hidden=true href=#11-acid>#</a></h3><p>ACID，即 Atomicity、Consistency、Isolation 和 Durability。显然，各个数据库能提供的安全性保证是不一样的，因此 ACID 在各个数据库上的表现也会有所区别，但是还是有比较笼统的概念的。</p><h4 id=111-原子性-atomicity>1.1.1 原子性 Atomicity<a hidden class=anchor aria-hidden=true href=#111-原子性-atomicity>#</a></h4><p>想象这样一个场景，客户端发起了包含多个写操作的请求，而这个请求执行到一半时因为各种原因失败了（数据库错误/执行时判断失败），此时客户端该如何继续变成了问题；为了让客户端不用管理请求的执行进度，我们将其包装为一个整体的“原子操作”：如果执行失败，那么数据库必须丢弃或者撤销那些局部完成的修改。</p><p>通过原子性保证，如果事务中止，应用程序可以确定没有实质发生任何更改，所以可以安全地重试（因此又被称为可中止性）。</p><h4 id=112-一致性-consistency>1.1.2 一致性 Consistency<a hidden class=anchor aria-hidden=true href=#112-一致性-consistency>#</a></h4><p>ACID 中的一致性指的是数据层面状态的一致性，例如数据库中 A 的值一定是 B 的值的两倍，那么从满足该一致性的状态开始，执行一个合法的事务后，得到的结果也应满足这个约束。显然，数据之中的约束是应用层定义的，数据库通常只能提供有限的约束工具，例如外键约束和唯一性约束，因此一致性通常是由应用程序本身来维护的。</p><h4 id=113-隔离性-isolation>1.1.3 隔离性 Isolation<a hidden class=anchor aria-hidden=true href=#113-隔离性-isolation>#</a></h4><p>当多个客户端同时使用数据库时，如果访问同一记录，那么便会产生并发问题。为了让应用程序无需考虑并发竞争，数据库提供隔离性保证，这意味着应用执行事务时，从其视角来看所有的事务都是按照顺序在执行的，而数据库也要使用各种机制，确保这些事务在执行完成后所得的结果与顺序执行结果一致，这样才能符合应用的预期；实际中由于性能问题，数据库很少能够提供这样严格的隔离性，因此各个数据库提供的隔离性可能不同。</p><h4 id=114-持久性-durability>1.1.4 持久性 Durability<a hidden class=anchor aria-hidden=true href=#114-持久性-durability>#</a></h4><p>持久性是大部分数据存储系统的基础保证，即数据写入（事务提交）完成后，不管发生什么情况，写入的数据都不应丢失。显然，持久性也是有限，不同数据库所提供的持久性保证都不一样：分布式数据库与单机数据库相比，提供的持久性通常会更好。</p><p>综上所述，原子性保证对于各类数据库来说比较统一；一致性保证与数据库提供的工具有关，且责任在应用层；隔离性保证太过绝对，在各类数据库中都不太一样；持久性保证也很模糊，各类数据库或者说实际情况下都不一样。总而言之，也就原子性比较统一，其他概念在实际实现中都是比较模糊的。</p><h3 id=12-单对象写入与多对象事务>1.2 单对象写入与多对象事务<a hidden class=anchor aria-hidden=true href=#12-单对象写入与多对象事务>#</a></h3><p>在前文提到了 ACID 的安全性保证，在数据库设计中，通常只用关心原子性和隔离性。对于持久性，这是存储系统的基石，无需额外讨论；对于一致性，如果应用提供正确的操作，而数据库保证操作的原子性和隔离性，那么便能保证一致性，因此也不单独讨论，因此我们主要聚焦原子性与隔离性在数据库中的设计和实现。</p><p>接下来我们简单思考一下事务的一些注意事项。</p><h4 id=121-单对象写入>1.2.1 单对象写入<a hidden class=anchor aria-hidden=true href=#121-单对象写入>#</a></h4><p>我们知道，最底层的原子性保证来源于 CPU 的设计，且其只保证了极其有限的操作；对于数据库存储的对象来说，那就更不存在原子性了，因此就算是单对象，其原子性和隔离性也不是天然的：例如数据库写入 100KB 的单对象时，在写的中途也要保证不被读到部分更新的数据（隔离性）；在写的中途失败时，写造成的修改也要能够撤销（原子性）。如果没有单对象的原子性和隔离性保证，那么就更别谈多对象的处理了。</p><p>因此存储引擎在设计时便考虑了单对象的原子性和隔离性的支持，例如使用日志来实现原子性（可恢复可撤销），而使用锁来实现对象的隔离性。因此在我们通常的讨论中，单对象的原子性和隔离性太过基础，我们默认其是底层提供的基础保证，事务（多操作聚合）是在此基础之上的讨论，这也是为什么这部分标题并未称为“单对象事务”。</p><h4 id=122-多对象事务>1.2.2 多对象事务<a hidden class=anchor aria-hidden=true href=#122-多对象事务>#</a></h4><p>在分布式数据库中，多对象事务还是有一定复杂度的，原因在于这些对象可能由于分区存在于不同的子数据库实例中。多对象事务对于一致性的保证有重要的帮助作用，例如同步更新的二级索引、外键引用的有效性、多文档同时更新等。</p><h4 id=123-处理错误与中止>1.2.3 处理错误与中止<a hidden class=anchor aria-hidden=true href=#123-处理错误与中止>#</a></h4><p>前文我们提到事务提供了失败之后可以安全重试的保障，因此对于错误和中止，我们尽量尝试重试，但重试机制还有许多问题需要注意：</p><ol><li>事务执行成功，但应用认为执行失败（各种原因导致未收到成功确认），此时产生的重试可能出现问题：可以提供事务 id 以确保已提交的事务不会重复执行；</li><li>外因中止，例如系统超负荷运行导致事务执行失败，反复重试反而会加重系统负担：设定重试次数上限；</li><li>事务本身操作违反约束导致的失败：应用应调整操作内容而不是继续重试；</li><li>事务只能保证数据库内无副作用，如果有机制与数据库外操作相关，重试可能触发数据库外的副作用，例如更新时发送邮件，重试可能导致多次发送：涉及到多系统事务，可以使用两阶段提交；</li><li>本应进行重试的应用失效，导致重试操作丢失，可能导致数据丢失：应用也要具有持久化的能力。</li></ol><h2 id=二弱隔离级别>二、弱隔离级别<a hidden class=anchor aria-hidden=true href=#二弱隔离级别>#</a></h2><p>接下来我们探讨事务的隔离性，由于这一部分比较复杂，因此单独进行说明。</p><p>前文提到隔离性是为了解决数据库的并发访问问题而抽象出的概念，严格的隔离性使得并发操作执行的结果，与其按照顺序执行的结果一致，这意味着在应用执行事务时，无需关心并发的问题。然而在实际中，这种串行化的隔离性严重限制了数据库的性能，因此通常数据库提供较弱一些的隔离性保证，或是提供一些可选的隔离性配置。</p><p>在非串行化隔离下，总会出现各种各样的问题，我们将问题归纳为以下几种进行标记，并讨论各种隔离级别对这些常见问题的解决：</p><ul><li><sup>A</sup>脏读</li><li><sup>B</sup>脏写</li><li><sup>C</sup>读倾斜</li><li><sup>D</sup>写倾斜</li><li><sup>E</sup>幻读</li><li><sup>F</sup>更新丢失</li></ul><h3 id=21-读-提交>2.1 读-提交<a hidden class=anchor aria-hidden=true href=#21-读-提交>#</a></h3><p>读-提交通常是最基础的隔离级别，它只提供两个保证：</p><ol><li>解决 <strong><sup>A</sup>脏读</strong>：读数据库时，只能看到已成功提交的数据；</li><li>解决 <strong><sup>B</sup>脏写</strong>：写数据库时，只会覆盖已成功提交的数据。</li></ol><p>关于为什么要防止脏读，原因很明显就不再赘述；我们重点关注脏写的问题：</p><p>当有两个事务同时在执行时，前一个事务的写还未提交，而后一个事务想要写数据，如果在未提交的数据上覆盖，则称为脏写，最简单的处理方式是等待直到待写的数据被提交再进行。</p><p>脏写会带来什么问题呢，想象这样一个场景，用户提交的事务需要修改 A、B 两处数据，同时有两个用户提交了事务在执行：</p><p><img alt=脏写 loading=lazy src=/img/dirty_write.svg></p><p>最终导致 A 为用户 2 的数据，B 为用户 1 的数据；脏写会导致不同事务的并发写入最终混杂在一起。</p><h4 id=211-读-提交的实现>2.1.1 读-提交的实现<a hidden class=anchor aria-hidden=true href=#211-读-提交的实现>#</a></h4><p>数据库要实现读-提交，那么就要解决 <strong><sup>A</sup>脏读</strong> 和 <strong><sup>B</sup>脏写</strong>。</p><h5 id=的解决><strong><sup>A</sup>脏读</strong> 的解决<a hidden class=anchor aria-hidden=true href=#的解决>#</a></h5><p>一种方式是直接加读写锁，一旦数据正在被写入，则排斥读操作，但是这会导致只读事务的执行受阻，严重影响只读事务的响应延迟；因此大多数数据库使用另一种方式来实现：对于每个待更新的对象，数据库都会维护其旧值和当前持锁事务将要设置的新值两个版本，在这个事务提交之前，其他事务读取到的都是旧值，也就防止了 <strong><sup>A</sup>脏读</strong>。</p><h5 id=的解决-1><strong><sup>B</sup>脏写</strong> 的解决<a hidden class=anchor aria-hidden=true href=#的解决-1>#</a></h5><p>显然对于并发写，最简单的方法便是加写锁，数据库通常采用行级锁来防止 <strong><sup>B</sup>脏写</strong>。</p><h3 id=22-快照级别隔离与可重复读>2.2 快照级别隔离与可重复读<a hidden class=anchor aria-hidden=true href=#22-快照级别隔离与可重复读>#</a></h3><p>显然读-提交级别还有解决不了的问题，那便是 <strong><sup>C</sup>读倾斜</strong>。考虑以下场景，用户正在使用事务 T<sub>1</sub> 查询两个账户的总余额，而后台有个程序正在用事务 T<sub>2</sub> 执行两个账户之间的转账：</p><p><img alt=读倾斜 loading=lazy src=/img/read_skew.svg></p><p>T<sub>2</sub> 更新了两个账户的余额，完成转账操作，两个账户的总额不变仍是 200；用户在查询 Account1 的余额时，由于 T<sub>2</sub> 还未提交，因此读取到的是读-提交保证的旧值 100，当其查询 Account2 的余额时，由于 T<sub>2</sub> 已经提交，因此读取到的是新值 200，符合读-提交的隔离性保证，但因此得出的总余额结果却是 300，这便是 <strong><sup>C</sup>读倾斜</strong>，又可称为 <strong><sup>C</sup>不可重复度读</strong>。</p><p><strong><sup>C</sup>读倾斜</strong> 产生的原因是同一个事务内读取到了两个版本的数据，旧的 Account1 和新的 Account2，倘若 T1 在最后添加一个 Account1 的余额查询操作，便会发现前后两次查询操作结果不一致，这便是 <strong><sup>C</sup>不可重复度读</strong> 这个名称的由来。</p><p>在以下场景中 <strong><sup>C</sup>读倾斜</strong> 很有可能发生：</p><ol><li>备份场景：在备份过程中数据库数据在不断更新，备份的数据可能新旧混杂，一致性被破坏；</li><li>分析查询与完整性检查：由于数据在不断更新，这类查询和检查无法实现。</li></ol><h4 id=的解决-2><strong><sup>C</sup>读倾斜</strong> 的解决<a hidden class=anchor aria-hidden=true href=#的解决-2>#</a></h4><p>显然，事务在执行过程中应当读取一致的数据（同一个版本的数据），这为我们指明了版本控制这一思路。在读-提交中，为了解决 <strong><sup>A</sup>脏读</strong>，我们维护了数据的新旧值，当写事务为提交时读旧值，提交后读新值；为了解决 <strong><sup>C</sup>读倾斜</strong>，我们要更进一步，就算<strong>写事务已经提交</strong>，其旧值甚至更旧的值仍可能需要维护：有之前正在执行的事务需要读这个数据。</p><p>这意味着旧值不再是一个临时维护的值，而是跟新值一样，是长期需要管理的值；考虑到多个正在进行的事务可能会在不同的时间点查看数据库状态，所以数据库保留了对象多个不同的提交版本，这种技术因此也被称为多版本并发控制（Multi-Version Concurrency Control，MVCC）。</p><p>事务执行在数据库完整的一个版本快照上，因此又被称之为快照级别隔离。当事务执行时，首先赋予一个唯一的、单调递增的事务 ID。每当事务向数据库内写入新内容是，所写的数据都会被标记写入者的事务 ID。</p><p>那么对于一个事务 T<sub>k</sub>，其能访问的数据是哪些版本呢？考虑下图的场景：</p><p><img alt=MVCC loading=lazy src=/img/mvcc.svg></p><p>对于 事务 T<sub>k</sub> 开始时：</p><ol><li>还未提交的事务 T<sub>a</sub>：显然这部分数据不可见；</li><li>中止的事务：由原子性保证这部分数据不可见；</li><li>晚于 T<sub>k</sub> 的事务：显然不可见；</li><li>其他所有写入都应可见。</li></ol><p>简单来说，只有<strong>事务开始</strong>时，数据库内已提交的事务才可见；事务开始后数据的可见性不再变化，形成了“快照”。</p><p>多版本看起来并不复杂，但是要考虑其与数据库其他功能的兼容性，最重要的便是索引与快照级别隔离兼容的处理。</p><h4 id=索引与快照级别隔离>索引与快照级别隔离<a hidden class=anchor aria-hidden=true href=#索引与快照级别隔离>#</a></h4><p>显然，在多版本数据库中，索引指向的数据有多个版本，最简单的方法便是索引指向所有版本，找出后再根据版本进行过滤；对于使用 B-Tree 的数据库，还可以使用写时复制的技术：</p><p><img alt=copy_on_write loading=lazy src=/img/copy_on_write.png></p><p>如图所示，在 B-Tree 中想要修改 D，写入新数据 D&rsquo;，那么要修改其对应父节点中存储的指针，因此父节点也创建了新版本，同理一直往上，直到创建了新版本的根节点 R&rsquo;。其中不受影响的 B、C 节点及其子节点，在两个树中被共享。</p><p>在每个写入事务开始时创建一个新的版本树，然后在整个事务流程过程中都使用这个新树的根节点开始查找，无论是数据还是索引都是如此；在这个树中所能见到的数据都是这个事务所应该能看到的数据，因此无需进行版本过滤；显然，这些根节点就形成一系列快照。</p><h3 id=23-防止-f更新丢失>2.3 防止 <sup>F</sup>更新丢失<a hidden class=anchor aria-hidden=true href=#23-防止-f更新丢失>#</a></h3><p>就算是快照级别隔离也存在问题没有解决，<sup>F</sup>更新丢失便是其中一个。<sup>F</sup>更新丢失发生在 read-modify-write 这样的操作流程里，这个流程十分常见，比如：</p><ul><li>计数器：一定是要读取当前值再进行修改</li><li>修改复杂对象的一部分</li></ul><p>广义来说，<sup>F</sup>更新丢失也会出现在其他场景，比如 <a href=./brief-notes-about-data-system.md>有关数据系统的一些简要笔记</a> 中的写冲突部分，当两个用户并发写同一个位置的数据时，便会形成写冲突，某些解决方案会最终采用定义上最新的数据，造成<sup>F</sup>更新丢失。</p><h4 id=原子写操作>原子写操作<a hidden class=anchor aria-hidden=true href=#原子写操作>#</a></h4><p>读-修改-写产生的问题不是新问题，此事在经典多线程程序中亦有记载，可以使用原子操作来解决。在多数关系数据库中，简单的 UPDATE 都是并发安全的，是数据库提供的原子更新操作。要实现原子操作，通常采取对读取对象加独占锁的方式来实现，这种技术有时被称为游标稳定性；另一种方式是强制所有的原子操作都在指定的单线程上执行，根据使用场景，这种方式的效率也并不低。</p><h4 id=显式加锁>显式加锁<a hidden class=anchor aria-hidden=true href=#显式加锁>#</a></h4><p>由于原子操作提供的保证有限，无法适应一些应用层逻辑上的安全保证，因此数据库都提供了常见的锁机制。例如：SELECT &mldr; FOR UPDATE，将满足指定条件的行都选出来，标记为 FOR UPDATE，即加上锁。</p><p>如果数据库没有提供前文提到的原子写操作，用锁也可以很容易自己实现。</p><h4 id=自动检测更新丢失>自动检测更新丢失<a hidden class=anchor aria-hidden=true href=#自动检测更新丢失>#</a></h4><p>前文提到的两种方式都是把操作串行化来避免<sup>F</sup>更新丢失，是一种悲观的策略；实际上，操作并行化，并非一定会出现<sup>F</sup>更新丢失，例如一个操作在读-修改-写，另一个操作在读-修改-写到别的位置，实际上并未冲突。因此可以采取一些乐观的策略，比如自动检测更新丢失。</p><p>借助于多版本，我们可以很简单的检测出<sup>F</sup>更新丢失：当事务在读-修改-写时，最后写回时发现值的版本更新了，那么说明遇到了冲突，如果写入便会发生<sup>F</sup>更新丢失；当检测到后，可以回退事务，并使用原子的更新操作来重新执行。</p><h4 id=原子比较和设置>原子比较和设置<a hidden class=anchor aria-hidden=true href=#原子比较和设置>#</a></h4><p>熟悉多线程编程便会知道，CAS 原子指令很有用，其实可以看成是弱化版的自动<sup>F</sup>更新丢失检测。自动更新丢失检测是使用版本号来判断，而 CAS 是根据值来判断。</p><p>如果数据库提供了原子性的 CAS 指令，要谨慎使用，原因是多版本技术下，CAS 不一定能检测到版本变化，要注意其适用范围。</p><h4 id=冲突解决与复制>冲突解决与复制<a hidden class=anchor aria-hidden=true href=#冲突解决与复制>#</a></h4><p>前文提到的方式实际上都是避免冲突发生，从而避免更新丢失的，然而在多副本数据库中，需要加锁的部分可能横跨多个节点，锁的实现需要考虑很多额外的东西；在多主或者无主系统中，甚至无法使用锁，因此只能在冲突发生后来进行解决，可以参照<a href=./brief-notes-about-data-system.md>有关数据系统的一些简要笔记</a>写冲突部分。</p><h3 id=24-d写倾斜与e幻读>2.4 <sup>D</sup>写倾斜与<sup>E</sup>幻读<a hidden class=anchor aria-hidden=true href=#24-d写倾斜与e幻读>#</a></h3><h3 id=25-串行化>2.5 串行化<a hidden class=anchor aria-hidden=true href=#25-串行化>#</a></h3><h4 id=严格串行执行事务>严格串行执行事务<a hidden class=anchor aria-hidden=true href=#严格串行执行事务>#</a></h4><h4 id=两阶段加锁-2pl>两阶段加锁 2PL<a hidden class=anchor aria-hidden=true href=#两阶段加锁-2pl>#</a></h4><h4 id=可串行化的快照隔离>可串行化的快照隔离<a hidden class=anchor aria-hidden=true href=#可串行化的快照隔离>#</a></h4></div><footer class=post-footer><ul class=post-tags><li><a href=https://xinrea.cn/tags/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/>数据系统</a></li><li><a href=https://xinrea.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a></li><li><a href=https://xinrea.cn/tags/%E7%AC%94%E8%AE%B0/>笔记</a></li><li><a href=https://xinrea.cn/tags/%E4%BA%8B%E5%8A%A1/>事务</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://xinrea.cn/>杏仁儿的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>