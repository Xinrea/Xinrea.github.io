<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>数据系统事务的简单探讨 | 杏仁儿的博客</title><meta name=keywords content="数据系统,数据库,笔记,事务"><meta name=description content="前言
为了降低应用程序开发人员的心智负担，数据系统提供事务这一机制来简化各种各样的常见问题。事务将应用程序的多个读写操作捆绑在一起，称为一个逻辑操作单元。"><meta name=author content><link rel=canonical href=https://xinrea.cn/posts/transaction-in-data-system/><link crossorigin=anonymous href=/assets/css/stylesheet.937463db118e3962617a80b6c7b1a76e9996bd6ba48012c23560055d0bbabfc1.css integrity="sha256-k3Rj2xGOOWJheoC2x7GnbpmWvWukgBLCNWAFXQu6v8E=" rel="preload stylesheet" as=style><link rel=icon href=https://xinrea.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xinrea.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://xinrea.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://xinrea.cn/apple-touch-icon.png><link rel=mask-icon href=https://xinrea.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://xinrea.cn/posts/transaction-in-data-system/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css integrity=sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js integrity=sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous onload=renderMathInElement(document.body)></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-YDJZ0WLTD6"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-YDJZ0WLTD6")}</script><meta property="og:url" content="https://xinrea.cn/posts/transaction-in-data-system/"><meta property="og:site_name" content="杏仁儿的博客"><meta property="og:title" content="数据系统事务的简单探讨"><meta property="og:description" content="前言 为了降低应用程序开发人员的心智负担，数据系统提供事务这一机制来简化各种各样的常见问题。事务将应用程序的多个读写操作捆绑在一起，称为一个逻辑操作单元。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-25T00:00:00+00:00"><meta property="article:modified_time" content="2025-05-14T15:52:47+08:00"><meta property="article:tag" content="数据系统"><meta property="article:tag" content="数据库"><meta property="article:tag" content="笔记"><meta property="article:tag" content="事务"><meta name=twitter:card content="summary"><meta name=twitter:title content="数据系统事务的简单探讨"><meta name=twitter:description content="前言
为了降低应用程序开发人员的心智负担，数据系统提供事务这一机制来简化各种各样的常见问题。事务将应用程序的多个读写操作捆绑在一起，称为一个逻辑操作单元。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://xinrea.cn/posts/"},{"@type":"ListItem","position":2,"name":"数据系统事务的简单探讨","item":"https://xinrea.cn/posts/transaction-in-data-system/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"数据系统事务的简单探讨","name":"数据系统事务的简单探讨","description":"前言 为了降低应用程序开发人员的心智负担，数据系统提供事务这一机制来简化各种各样的常见问题。事务将应用程序的多个读写操作捆绑在一起，称为一个逻辑操作单元。\n","keywords":["数据系统","数据库","笔记","事务"],"articleBody":"前言 为了降低应用程序开发人员的心智负担，数据系统提供事务这一机制来简化各种各样的常见问题。事务将应用程序的多个读写操作捆绑在一起，称为一个逻辑操作单元。\n执行事务只有两种结果，要么成功要么失败，且失败无副作用，不会产生任何修改；因此，如果失败，那么应用程序可以放心重试。有了事务，应用程序可以不用考虑某些内部潜在的错误以及复杂的并发性问题，这些都由数据库自己来处理，因此又被称之为安全性保证。\n一、理解事务 我们知道事务是数据库提供的安全性保证，用于屏蔽数据库内内部的错误以及并发问题，那么这个安全性保证具体包含哪些方面呢？这便是我们常说的 ACID。\n1.1 ACID ACID，即 Atomicity、Consistency、Isolation 和 Durability。显然，各个数据库能提供的安全性保证是不一样的，因此 ACID 在各个数据库上的表现也会有所区别，但是还是有比较笼统的概念的。\n1.1.1 原子性 Atomicity 想象这样一个场景，客户端发起了包含多个写操作的请求，而这个请求执行到一半时因为各种原因失败了（数据库错误/执行时判断失败），此时客户端该如何继续变成了问题；为了让客户端不用管理请求的执行进度，我们将其包装为一个整体的“原子操作”：如果执行失败，那么数据库必须丢弃或者撤销那些局部完成的修改。\n通过原子性保证，如果事务中止，应用程序可以确定没有实质发生任何更改，所以可以安全地重试（因此又被称为可中止性）。\n1.1.2 一致性 Consistency ACID 中的一致性指的是数据层面状态的一致性，例如数据库中 A 的值一定是 B 的值的两倍，那么从满足该一致性的状态开始，执行一个合法的事务后，得到的结果也应满足这个约束。显然，数据之中的约束是应用层定义的，数据库通常只能提供有限的约束工具，例如外键约束和唯一性约束，因此一致性通常是由应用程序本身来维护的。\n1.1.3 隔离性 Isolation 当多个客户端同时使用数据库时，如果访问同一记录，那么便会产生并发问题。为了让应用程序无需考虑并发竞争，数据库提供隔离性保证，这意味着应用执行事务时，从其视角来看所有的事务都是按照顺序在执行的，而数据库也要使用各种机制，确保这些事务在执行完成后所得的结果与顺序执行结果一致，这样才能符合应用的预期；实际中由于性能问题，数据库很少能够提供这样严格的隔离性，因此各个数据库提供的隔离性可能不同。\n1.1.4 持久性 Durability 持久性是大部分数据存储系统的基础保证，即数据写入（事务提交）完成后，不管发生什么情况，写入的数据都不应丢失。显然，持久性也是有限，不同数据库所提供的持久性保证都不一样：分布式数据库与单机数据库相比，提供的持久性通常会更好。\n综上所述，原子性保证对于各类数据库来说比较统一；一致性保证与数据库提供的工具有关，且责任在应用层；隔离性保证太过绝对，在各类数据库中都不太一样；持久性保证也很模糊，各类数据库或者说实际情况下都不一样。总而言之，也就原子性比较统一，其他概念在实际实现中都是比较模糊的。\n1.2 单对象写入与多对象事务 在前文提到了 ACID 的安全性保证，在数据库设计中，通常只用关心原子性和隔离性。对于持久性，这是存储系统的基石，无需额外讨论；对于一致性，如果应用提供正确的操作，而数据库保证操作的原子性和隔离性，那么便能保证一致性，因此也不单独讨论，因此我们主要聚焦原子性与隔离性在数据库中的设计和实现。\n接下来我们简单思考一下事务的一些注意事项。\n1.2.1 单对象写入 我们知道，最底层的原子性保证来源于 CPU 的设计，且其只保证了极其有限的操作；对于数据库存储的对象来说，那就更不存在原子性了，因此就算是单对象，其原子性和隔离性也不是天然的：例如数据库写入 100KB 的单对象时，在写的中途也要保证不被读到部分更新的数据（隔离性）；在写的中途失败时，写造成的修改也要能够撤销（原子性）。如果没有单对象的原子性和隔离性保证，那么就更别谈多对象的处理了。\n因此存储引擎在设计时便考虑了单对象的原子性和隔离性的支持，例如使用日志来实现原子性（可恢复可撤销），而使用锁来实现对象的隔离性。因此在我们通常的讨论中，单对象的原子性和隔离性太过基础，我们默认其是底层提供的基础保证，事务（多操作聚合）是在此基础之上的讨论，这也是为什么这部分标题并未称为“单对象事务”。\n1.2.2 多对象事务 在分布式数据库中，多对象事务还是有一定复杂度的，原因在于这些对象可能由于分区存在于不同的子数据库实例中。多对象事务对于一致性的保证有重要的帮助作用，例如同步更新的二级索引、外键引用的有效性、多文档同时更新等。\n1.2.3 处理错误与中止 前文我们提到事务提供了失败之后可以安全重试的保障，因此对于错误和中止，我们尽量尝试重试，但重试机制还有许多问题需要注意：\n事务执行成功，但应用认为执行失败（各种原因导致未收到成功确认），此时产生的重试可能出现问题：可以提供事务 id 以确保已提交的事务不会重复执行； 外因中止，例如系统超负荷运行导致事务执行失败，反复重试反而会加重系统负担：设定重试次数上限； 事务本身操作违反约束导致的失败：应用应调整操作内容而不是继续重试； 事务只能保证数据库内无副作用，如果有机制与数据库外操作相关，重试可能触发数据库外的副作用，例如更新时发送邮件，重试可能导致多次发送：涉及到多系统事务，可以使用两阶段提交； 本应进行重试的应用失效，导致重试操作丢失，可能导致数据丢失：应用也要具有持久化的能力。 二、弱隔离级别 接下来我们探讨事务的隔离性，由于这一部分比较复杂，因此单独进行说明。\n前文提到隔离性是为了解决数据库的并发访问问题而抽象出的概念，严格的隔离性使得并发操作执行的结果，与其按照顺序执行的结果一致，这意味着在应用执行事务时，无需关心并发的问题。然而在实际中，这种串行化的隔离性严重限制了数据库的性能，因此通常数据库提供较弱一些的隔离性保证，或是提供一些可选的隔离性配置。\n在非串行化隔离下，总会出现各种各样的问题，我们将问题归纳为以下几种进行标记，并讨论各种隔离级别对这些常见问题的解决：\nA脏读 B脏写 C读倾斜 D写倾斜 E幻读 F更新丢失 2.1 读-提交 读-提交通常是最基础的隔离级别，它只提供两个保证：\n解决 A脏读：读数据库时，只能看到已成功提交的数据； 解决 B脏写：写数据库时，只会覆盖已成功提交的数据。 关于为什么要防止脏读，原因很明显就不再赘述；我们重点关注脏写的问题：\n当有两个事务同时在执行时，前一个事务的写还未提交，而后一个事务想要写数据，如果在未提交的数据上覆盖，则称为脏写，最简单的处理方式是等待直到待写的数据被提交再进行。\n脏写会带来什么问题呢，想象这样一个场景，用户提交的事务需要修改 A、B 两处数据，同时有两个用户提交了事务在执行：\n最终导致 A 为用户 2 的数据，B 为用户 1 的数据；脏写会导致不同事务的并发写入最终混杂在一起。\n2.1.1 读-提交的实现 数据库要实现读-提交，那么就要解决 A脏读 和 B脏写。\na. A脏读 的解决 一种方式是直接加读写锁，一旦数据正在被写入，则排斥读操作，但是这会导致只读事务的执行受阻，严重影响只读事务的响应延迟；因此大多数数据库使用另一种方式来实现：对于每个待更新的对象，数据库都会维护其旧值和当前持锁事务将要设置的新值两个版本，在这个事务提交之前，其他事务读取到的都是旧值，也就防止了 A脏读。\nb. B脏写 的解决 显然对于并发写，最简单的方法便是加写锁，数据库通常采用行级锁来防止 B脏写。\n2.2 快照级别隔离与可重复读 显然读-提交级别还有解决不了的问题，那便是 C读倾斜。考虑以下场景，用户正在使用事务 T1 查询两个账户的总余额，而后台有个程序正在用事务 T2 执行两个账户之间的转账：\nT2 更新了两个账户的余额，完成转账操作，两个账户的总额不变仍是 200；用户在查询 Account1 的余额时，由于 T2 还未提交，因此读取到的是读-提交保证的旧值 100，当其查询 Account2 的余额时，由于 T2 已经提交，因此读取到的是新值 200，符合读-提交的隔离性保证，但因此得出的总余额结果却是 300，这便是 C读倾斜，又可称为 C不可重复度读。\nC读倾斜 产生的原因是同一个事务内读取到了两个版本的数据，旧的 Account1 和新的 Account2，倘若 T1 在最后添加一个 Account1 的余额查询操作，便会发现前后两次查询操作结果不一致，这便是 C不可重复度读 这个名称的由来。\n在以下场景中 C读倾斜 很有可能发生：\n备份场景：在备份过程中数据库数据在不断更新，备份的数据可能新旧混杂，一致性被破坏； 分析查询与完整性检查：由于数据在不断更新，这类查询和检查无法实现。 换个角度来看，事务 T2 实际上在 T1 执行的过程中，修改了 T1 的查询结果（对比正常查询），这使得 T1 出现了被称之为 E幻读 的问题。\n2.2.1 C读倾斜 的解决 显然，事务在执行过程中应当读取一致的数据（同一个版本的数据），这为我们指明了版本控制这一思路。在读-提交中，为了解决 A脏读，我们维护了数据的新旧值，当写事务为提交时读旧值，提交后读新值；为了解决 C读倾斜，我们要更进一步，就算写事务已经提交，其旧值甚至更旧的值仍可能需要维护：有之前正在执行的事务需要读这个数据。\n这意味着旧值不再是一个临时维护的值，而是跟新值一样，是长期需要管理的值；考虑到多个正在进行的事务可能会在不同的时间点查看数据库状态，所以数据库保留了对象多个不同的提交版本，这种技术因此也被称为多版本并发控制（Multi-Version Concurrency Control，MVCC）。\n事务执行在数据库完整的一个版本快照上，因此又被称之为快照级别隔离。当事务执行时，首先赋予一个唯一的、单调递增的事务 ID。每当事务向数据库内写入新内容是，所写的数据都会被标记写入者的事务 ID。\n那么对于一个事务 Tk，其能访问的数据是哪些版本呢？考虑下图的场景：\n对于 事务 Tk 开始时：\n还未提交的事务 Ta：显然这部分数据不可见； 中止的事务：由原子性保证这部分数据不可见； 晚于 Tk 的事务：显然不可见； 其他所有写入都应可见。 简单来说，只有事务开始时，数据库内已提交的事务才可见；事务开始后数据的可见性不再变化，形成了“快照”。\n多版本看起来并不复杂，但是要考虑其与数据库其他功能的兼容性，最重要的便是索引与快照级别隔离兼容的处理。\n2.2.2 索引与快照级别隔离 显然，在多版本数据库中，索引指向的数据有多个版本，最简单的方法便是索引指向所有版本，找出后再根据版本进行过滤；对于使用 B-Tree 的数据库，还可以使用写时复制的技术：\n如图所示，在 B-Tree 中想要修改 D，写入新数据 D’，那么要修改其对应父节点中存储的指针，因此父节点也创建了新版本，同理一直往上，直到创建了新版本的根节点 R’。其中不受影响的 B、C 节点及其子节点，在两个树中被共享。\n在每个写入事务开始时创建一个新的版本树，然后在整个事务流程过程中都使用这个新树的根节点开始查找，无论是数据还是索引都是如此；在这个树中所能见到的数据都是这个事务所应该能看到的数据，因此无需进行版本过滤；显然，这些根节点就形成一系列快照。\n2.3 防止 F更新丢失 就算是快照级别隔离也存在问题没有解决，F更新丢失 便是其中一个。F更新丢失 发生在 read-modify-write 这样的操作流程里，这个流程十分常见，比如：\n计数器：一定是要读取当前值再进行修改 修改复杂对象的一部分 广义来说，F更新丢失 也会出现在其他场景，比如 有关数据系统的一些简要笔记 中的写冲突部分，当两个用户并发写同一个位置的数据时，便会形成写冲突，某些解决方案会最终采用定义上最新的数据，造成 F更新丢失。\n2.3.1 原子写操作 读-修改-写产生的问题不是新问题，此事在经典多线程程序中亦有记载，可以使用原子操作来解决。在多数关系数据库中，简单的 UPDATE 都是并发安全的，是数据库提供的原子更新操作。要实现原子操作，通常采取对读取对象加独占锁的方式来实现，这种技术有时被称为游标稳定性；另一种方式是强制所有的原子操作都在指定的单线程上执行，根据使用场景，这种方式的效率也并不低。\n2.3.2 显式加锁 由于原子操作提供的保证有限，无法适应一些应用层逻辑上的安全保证，因此数据库都提供了常见的锁机制。例如：SELECT … FOR UPDATE，将满足指定条件的行都选出来，标记为 FOR UPDATE，即加上锁。\n如果数据库没有提供前文提到的原子写操作，用锁也可以很容易自己实现。\n2.3.3 自动检测更新丢失 前文提到的两种方式都是把操作串行化来避免 F更新丢失，是一种悲观的策略；实际上，操作并行化，并非一定会出现 F更新丢失，例如一个操作在读-修改-写，另一个操作在读-修改-写到别的位置，实际上并未冲突。因此可以采取一些乐观的策略，比如自动检测更新丢失。\n借助于多版本，我们可以很简单的检测出 F更新丢失：当事务在读-修改-写时，最后写回时发现值的版本更新了，那么说明遇到了冲突，如果写入便会发生 F更新丢失；当检测到后，可以回退事务，并使用原子的更新操作来重新执行。\n2.3.4 原子比较和设置 熟悉多线程编程便会知道，CAS 原子指令很有用，其实可以看成是弱化版的自动 F更新丢失 检测。自动更新丢失检测是使用版本号来判断，而 CAS 是根据值来判断。\n如果数据库提供了原子性的 CAS 指令，要谨慎使用，原因是多版本技术下，CAS 不一定能检测到版本变化，要注意其适用范围。\n2.3.5 冲突解决与复制 前文提到的方式实际上都是避免冲突发生，从而避免更新丢失的，然而在多副本数据库中，需要加锁的部分可能横跨多个节点，锁的实现需要考虑很多额外的东西；在多主或者无主系统中，甚至无法使用锁，因此只能在冲突发生后来进行解决，可以参照有关数据系统的一些简要笔记写冲突部分。\n2.4 D写倾斜 前文介绍了一些隔离级别的常见问题，是比较直接的；但在实际的数据系统中，数据间可能暗含一些约束关系，很容易在对数据的操作中破坏这些关系，造成数据不一致，这便是 D写倾斜。\n2.4.1 D写倾斜 举一个简单的例子，假设有两个用户同时发起一个事务操作，内容是查询一件物品的空闲情况，如果是空闲则进行预定；我们可以预想到这样一个情况：两个用户都查询了物品的空闲情况，均为可用，因此都进行了预定操作。\n如果预定操作需要修改物品的状态（例如填入预定者信息），那么两个事务尝试更新同一条数据，可能出现前文提到的 F更新丢失 的问题；如果预定操作不需要修改物品的状态，而是在用户各自的数据中进行记录，那么两个事务执行完成后会破坏数据的一致性关系：两个用户都预定了同一件物品，显然是不允许的。这便是 D写倾斜。\n与 C读倾斜（不可重复读） 类似，D写倾斜 发生在事务执行的过程中，操作了不同版本的数据。在 C读倾斜 中比较明显，两次读操作可能读取到的是不同版本的数据，造成了问题；而在 D写倾斜 中，这一关系比较隐含。\n以上文提到的例子来进行说明：物品只能由一个人预定，这一约束实际上将两个用户的数据关联在了一起（同一个物品只能在两个用户数据中出现一次），可以视为一个隐含的整体对象，当然，如果这真的是一个对象的话，两个事务在最后操作时会触发 F更新丢失 的问题，可以通过检查数据版本来进行检测；然而这样一个对象是不存在的，它们只是因约束关系而关联在一起，而版本检测无法在两个对象上进行，当然原子操作也不能在两个对象上进行。\n因此 D写倾斜 实际上是 F更新丢失 的 Max Pro 版本，许多方法在这个问题上失效了。通过总结 D写倾斜 的特征，我们可以发现，问题出现在读-写事务的执行过程中，如果一个事务的写会影响另一个事务的读，那么便可能出现 D写倾斜。\n2.4.2 D写倾斜的解决 前文提到 D写倾斜 之所以比 F更新丢失 复杂，是因为 D写倾斜 的约束关系是隐含的，而 F更新丢失 是显式的；因此我们可以通过显式的约束来避免 D写倾斜，这便是实体化冲突：在数据库中构建具体的对象，这些对象对应具体的隐含约束关系，通过对这些对象加锁来避免 D写倾斜。\n显然，我们把约束关系实例化为数据模型来管理，是十分复杂的，因此在实际中尽量避免使用这一方法；我们还可以使用可串行化隔离来避免 D写倾斜。\n说是避免 D写倾斜，实际上并不是针对 D写倾斜 的，而是通过可串行化隔离来避免所有的并发问题。可串行化隔离是最严格的隔离级别，所有的事务都在一个全局的顺序中执行，因此当然不会出现 D写倾斜 的问题；因此我们在下一节单独对串行化进行探讨。\n三、 串行化 事务的并发问题太多了，尤其是最后还碰上了很不好解决的 D写倾斜，弱隔离级别无法解决所有问题；因此我们可以考虑将所有的事务都串行化来避免这些问题，这便是可串行化隔离，是处理事务问题的大招。通过对串行化隔离的思考，大致可以分为以下几种实现方式：\n严格串行执行事务 两阶段加锁 2PL 可串行化的快照隔离 可见串行化也不一定要求严格串行执行，只需保证事务就算并行执行，最终结果与每次一个一个执行的结果相同。\n3.1 严格串行执行事务 这是最直白的想法，在单线程上执行所有的事务；提到单线程，便立马能够联想到 Redis，确实，Redis 便是串行执行解决事务问题的代表之一；单线程严格串行执行，除了能够忽视并发问题外，还避免了大量锁的开销，性能也不会太差。\n显然，这种方案的吞吐量上限是单个 CPU 核的吞吐量，因此更适合搭配主频高的 CPU 使用。\n随着 CPU 性能的逐年增长，Redis 的串行执行在大多数情况下不构成瓶颈，反而是接收请求和发送响应的 IO 部分逐渐力不从心了，因此新版本 Redis 进行了多线程改造，但只是在 IO 部分进行了多线程优化，指令（事务）执行仍然是单线程的。\n单线程串行执行要求指令必须简洁快速，不然会严重影响后续指令的执行，这意味着活动数据集必须能够完全载入内存，不然事务线程碰到 IO，那么所有指令都要原地等待了。\n同样的，这也意味着单线程串行执行的系统往往不支持交互式的多语句事务，没有办法等待用户交互式地输入指令执行，这会阻塞其他的指令；这里的交互式也包括这种常见场景：应用程序中创建一个事务 TX，然后在 TX 中逐一执行各种逻辑和指令。\n在这样的场景下，应用程序别无选择，只能一次提交整个事务代码交由数据库执行，这便形成了存储过程这一概念。\n3.1.1 存储过程 显然，就算数据库支持事务并发，如果网络开销较大，也可以使用这种方式进行优化；而且，由于一次性提供了整个事务代码，数据库还能据此进行优化和数据预载等操作；此外，还能预先在数据库中定义存储过程，应用只需调用执行即可。\n由于存储过程本质上是把应用执行的逻辑放到数据库上来执行，因此编写存储过程还需要单独的语言支持，通常是 SQL 的扩展语言，例如 PL/SQL、T-SQL 等，这增加了存储过程使用的门槛；好在许多数据库支持了使用现有的通用编程语言来实现存储过程，例如 Redis 的 Lua 等。\n由于存储过程在数据库服务器上运行，因此在运行时难以进行调试和管理；而数据库通常会连接大量应用使用，本身的性能压力就比较大，存储过程的执行会进一步加重数据库的负担，因此在使用存储过程时，通常需要对其进行性能分析和调优。\n3.1.2 分区 虽然单线程的性能还不错，但如今 CPU 早已不再是单核的时代了，需要想办法利用其余的 CPU 核心来提升性能。为此，我们可以将数据进行分区，让每个分区互相隔离，只在对应的核心上进行事务的执行，这样便能线性地提升数据库的事务性能。\n显然，分区后很有可能遇到一个事务需要跨多个分区的情况，这种情况下便只能将相应分区加锁后执行了，这会造成极大的性能损耗，算是分区的一个缺点；因此分区通常只能使用在简单的键值数据上，如果涉及二级索引，则很有可能跨分区操作造成性能下降。\n3.2 两阶段加锁 2PL 2PL 实际上就是给事务写操作的对象加上互斥锁，因此前文提到的 D写倾斜 便得到了解决：D写倾斜 的前提，便是一个事务的写会影响另一个事务的读，而 2PL 则是通过加锁来避免了这种情况。\n3.2.1 2PL 的性能 当有许多事务在执行时，由于 2PL 的存在，会出现许多读写锁的使用，很容易出现死锁的情况；因此在使用 2PL 时，通常会使用一些死锁检测机制来避免死锁的发生，这要求数据库能够检测并中止事务的执行\n其次，其主要缺点在于锁的大量使用带来的性能下降；另外，支持事务并发的数据库大多都支持交互式事务，这就意味着事务的执行时间可能很长，如果其获取的锁阻碍了其他事务，很有可能导致其他事务长时间等待；因此在开启 2PL 后数据库的访问延迟有非常大的不确定性。\n3.2.2 谓词锁 2PL 看起来是一个很好的解决方案，但是实际上还有一些问题需要处理：通过快照隔离简单解决掉的 E幻读 问题，2PL 却无法通过对对象加锁来解决。例如一个事务的查询是某个条件下的所有对象，而另一个事务是新增一个满足这个条件的对象，前者无法对不存在的对象加锁，因此其查询结果能够被后者所修改；因此 2PL 需要使用谓词锁来解决这个问题。\n谓词锁是对一个条件的加锁，而不是对一个对象的加锁；例如在上面的例子中，前者可以对满足条件的所有对象加锁，这样便能避免后者的插入操作影响前者的查询结果。具体的，可以在创建对象时检查其是否符合某个谓词锁的条件来实现。\n3.2.3 索引区间锁 使用谓词锁时，每次创建对象时，都要挨个检查谓词锁列表，看看是否符合其中某个条件，这会造成性能的下降；因此大多数使用 2PL 的数据库实际上是使用索引区间锁来实现的。\n索引区间锁实际上是对谓词锁的简化，同时为了保证安全性，简化的过程只是将谓词锁的范围扩大了，不会带来额外的风险。\n相较于谓词锁的具体条件，索引区间锁通过对索引的相应范围进行加锁来实现；由于条件通常使用索引进行查询，因此把锁放到索引上，当对象创建，构建相应的索引时便能够检测到。显然索引范围与谓词锁的具体范围是没法完全对应的，不过通过扩大索引加锁范围可以覆盖谓词锁的范围。\n虽然加锁范围变大了，但是检查的开销却小了许多；因此索引区间锁是一个折中的方案。当条件中没有合适的索引可以使用时，便退化为给整个表加锁。\n3.3 可串行化的快照隔离 SSI 前面提到的串行方式，总是想着在一开始就避免问题发生的可能性，确实保证了事务并发安全，但是却带来了性能的严重下降，这是对事务执行的悲观并发控制机制；实际上，就算事务可能操作同一个对象，也不一定会发生冲突，因此我们可以在事务执行时，允许其并发执行，等到最后提交时再进行检查，如果没有冲突则提交，否则回滚。\n这便是可串行化的快照隔离，一种乐观并发控制机制。这要求数据库有能力检测冲突以及中止相应的事务，这也是 SSI 的核心。由于 SSI 基于快照隔离，因此许多问题已经有成熟的解决方案了，我们只需关心如何解决 D写倾斜。\n首先，如果两个事务没有任何关联，那么显然并发执行是安全的；如果两个事务操作的对象有关联，才需要进行冲突判断。经过前文的分析我们知道 D写倾斜 出现于一个事务修改了另一个事务的查询结果，我们针对这一点进行解决。\n从读取者的视角来看，可以检查读取时，对象是否已经有未提交的修改了； 从写入者的视角来看，可以检查自己写入的对象有没有被其他事务读取过。 当然，并不需要在检测到时立即终止，因为在提交时有可能冲突已经消失了，因此是否中止放在最后，也就是提交时再进行判断。\n对于情况 1，读取事务注意到有未提交的修改，仍然正常进行执行处理，到最后提交时，如果这个未提交的修改被提交了，说明之前的操作基于过期的数据，因此要进行中止；如果还是处于未提交状态，则无需中止。\n对于情况 2，写入事务需要能够快速检测到相关对象是否有被读取过，因此可以参照索引区间锁的实现，在索引上添加特殊标记，由于冲突不一定发生，因此这个锁不会阻塞该事务的执行，而是关注其状态变化。到最后提交时，如果这个读取事务还未结束（事务还未提交），说明自己的写入会产生冲突，因此要进行中止；如果读取事务已经结束，说明自己的写入不会产生冲突，则可以提交。\n单靠其中一者是无法完成冲突检测的，因此两者同时在进行检测的操作。\n显然，当事务处理的对象较多时，既增大了冲突的可能性，也增大了检测的开销，因此通常要求读-写型事务要简短。总体来讲 SSI 下，执行缓慢事务的影响要更小一些；事务中止的比例会显著影响 SSI 的性能表现。\n总结 为了降低应用程序的复杂度，数据库提供了事务这一工具，使得应用程序得以放心操作数据而不必考虑许多基础问题；为了满足应用程序的需求（ACID 和性能），数据库支持了事务的并发执行；同时并发执行带来了许多问题，数据库为了解决这些问题，提供了多种隔离级别来满足不同的需求。\n通过对数据系统中这些事务并发问题处理方式的学习，应当能够认识到，在开发过程中随着问题复杂度的提升，通常不会有简单有效的办法能够一劳永逸的解决问题，我们更需要需要多种方案结合使用，并在其带来的性能损耗中进行权衡。\n","wordCount":"9707","inLanguage":"en","datePublished":"2025-02-25T00:00:00Z","dateModified":"2025-05-14T15:52:47+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://xinrea.cn/posts/transaction-in-data-system/"},"publisher":{"@type":"Organization","name":"杏仁儿的博客","logo":{"@type":"ImageObject","url":"https://xinrea.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xinrea.cn/ accesskey=h title="杏仁儿的博客 (Alt + H)">杏仁儿的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xinrea.cn/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://xinrea.cn/tags title=Tags><span>Tags</span></a></li><li><a href=https://xinrea.cn/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://xinrea.cn/projects title=Projects><span>Projects</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">数据系统事务的简单探讨</h1><div class=post-meta><span title='2025-02-25 00:00:00 +0000 UTC'>February 25, 2025</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e4%b8%80%e7%90%86%e8%a7%a3%e4%ba%8b%e5%8a%a1 aria-label=一、理解事务>一、理解事务</a><ul><li><a href=#11-acid aria-label="1.1 ACID">1.1 ACID</a><ul><li><a href=#111-%e5%8e%9f%e5%ad%90%e6%80%a7-atomicity aria-label="1.1.1 原子性 Atomicity">1.1.1 原子性 Atomicity</a></li><li><a href=#112-%e4%b8%80%e8%87%b4%e6%80%a7-consistency aria-label="1.1.2 一致性 Consistency">1.1.2 一致性 Consistency</a></li><li><a href=#113-%e9%9a%94%e7%a6%bb%e6%80%a7-isolation aria-label="1.1.3 隔离性 Isolation">1.1.3 隔离性 Isolation</a></li><li><a href=#114-%e6%8c%81%e4%b9%85%e6%80%a7-durability aria-label="1.1.4 持久性 Durability">1.1.4 持久性 Durability</a></li></ul></li><li><a href=#12-%e5%8d%95%e5%af%b9%e8%b1%a1%e5%86%99%e5%85%a5%e4%b8%8e%e5%a4%9a%e5%af%b9%e8%b1%a1%e4%ba%8b%e5%8a%a1 aria-label="1.2 单对象写入与多对象事务">1.2 单对象写入与多对象事务</a><ul><li><a href=#121-%e5%8d%95%e5%af%b9%e8%b1%a1%e5%86%99%e5%85%a5 aria-label="1.2.1 单对象写入">1.2.1 单对象写入</a></li><li><a href=#122-%e5%a4%9a%e5%af%b9%e8%b1%a1%e4%ba%8b%e5%8a%a1 aria-label="1.2.2 多对象事务">1.2.2 多对象事务</a></li><li><a href=#123-%e5%a4%84%e7%90%86%e9%94%99%e8%af%af%e4%b8%8e%e4%b8%ad%e6%ad%a2 aria-label="1.2.3 处理错误与中止">1.2.3 处理错误与中止</a></li></ul></li></ul></li><li><a href=#%e4%ba%8c%e5%bc%b1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab aria-label=二、弱隔离级别>二、弱隔离级别</a><ul><li><a href=#21-%e8%af%bb-%e6%8f%90%e4%ba%a4 aria-label="2.1 读-提交">2.1 读-提交</a><ul><li><a href=#211-%e8%af%bb-%e6%8f%90%e4%ba%a4%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="2.1.1 读-提交的实现">2.1.1 读-提交的实现</a><ul><li><a href=#a--%e7%9a%84%e8%a7%a3%e5%86%b3 aria-label="a. A脏读 的解决">a. A脏读 的解决</a></li><li><a href=#b--%e7%9a%84%e8%a7%a3%e5%86%b3 aria-label="b. B脏写 的解决">b. B脏写 的解决</a></li></ul></li></ul></li><li><a href=#22-%e5%bf%ab%e7%85%a7%e7%ba%a7%e5%88%ab%e9%9a%94%e7%a6%bb%e4%b8%8e%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb aria-label="2.2 快照级别隔离与可重复读">2.2 快照级别隔离与可重复读</a><ul><li><a href=#221--%e7%9a%84%e8%a7%a3%e5%86%b3 aria-label="2.2.1 C读倾斜 的解决">2.2.1 C读倾斜 的解决</a></li><li><a href=#222-%e7%b4%a2%e5%bc%95%e4%b8%8e%e5%bf%ab%e7%85%a7%e7%ba%a7%e5%88%ab%e9%9a%94%e7%a6%bb aria-label="2.2.2 索引与快照级别隔离">2.2.2 索引与快照级别隔离</a></li></ul></li><li><a href=#23-%e9%98%b2%e6%ad%a2-f%e6%9b%b4%e6%96%b0%e4%b8%a2%e5%a4%b1 aria-label="2.3 防止 F更新丢失">2.3 防止 F更新丢失</a><ul><li><a href=#231-%e5%8e%9f%e5%ad%90%e5%86%99%e6%93%8d%e4%bd%9c aria-label="2.3.1 原子写操作">2.3.1 原子写操作</a></li><li><a href=#232-%e6%98%be%e5%bc%8f%e5%8a%a0%e9%94%81 aria-label="2.3.2 显式加锁">2.3.2 显式加锁</a></li><li><a href=#233-%e8%87%aa%e5%8a%a8%e6%a3%80%e6%b5%8b%e6%9b%b4%e6%96%b0%e4%b8%a2%e5%a4%b1 aria-label="2.3.3 自动检测更新丢失">2.3.3 自动检测更新丢失</a></li><li><a href=#234-%e5%8e%9f%e5%ad%90%e6%af%94%e8%be%83%e5%92%8c%e8%ae%be%e7%bd%ae aria-label="2.3.4 原子比较和设置">2.3.4 原子比较和设置</a></li><li><a href=#235-%e5%86%b2%e7%aa%81%e8%a7%a3%e5%86%b3%e4%b8%8e%e5%a4%8d%e5%88%b6 aria-label="2.3.5 冲突解决与复制">2.3.5 冲突解决与复制</a></li></ul></li><li><a href=#24-d%e5%86%99%e5%80%be%e6%96%9c aria-label="2.4 D写倾斜">2.4 D写倾斜</a><ul><li><a href=#241-d%e5%86%99%e5%80%be%e6%96%9c aria-label="2.4.1 D写倾斜">2.4.1 D写倾斜</a></li><li><a href=#242-d%e5%86%99%e5%80%be%e6%96%9c%e7%9a%84%e8%a7%a3%e5%86%b3 aria-label="2.4.2 D写倾斜的解决">2.4.2 D写倾斜的解决</a></li></ul></li></ul></li><li><a href=#%e4%b8%89-%e4%b8%b2%e8%a1%8c%e5%8c%96 aria-label="三、 串行化">三、 串行化</a><ul><li><a href=#31-%e4%b8%a5%e6%a0%bc%e4%b8%b2%e8%a1%8c%e6%89%a7%e8%a1%8c%e4%ba%8b%e5%8a%a1 aria-label="3.1 严格串行执行事务">3.1 严格串行执行事务</a><ul><li><a href=#311-%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b aria-label="3.1.1 存储过程">3.1.1 存储过程</a></li><li><a href=#312-%e5%88%86%e5%8c%ba aria-label="3.1.2 分区">3.1.2 分区</a></li></ul></li><li><a href=#32-%e4%b8%a4%e9%98%b6%e6%ae%b5%e5%8a%a0%e9%94%81-2pl aria-label="3.2 两阶段加锁 2PL">3.2 两阶段加锁 2PL</a><ul><li><a href=#321-2pl-%e7%9a%84%e6%80%a7%e8%83%bd aria-label="3.2.1 2PL 的性能">3.2.1 2PL 的性能</a></li><li><a href=#322-%e8%b0%93%e8%af%8d%e9%94%81 aria-label="3.2.2 谓词锁">3.2.2 谓词锁</a></li><li><a href=#323-%e7%b4%a2%e5%bc%95%e5%8c%ba%e9%97%b4%e9%94%81 aria-label="3.2.3 索引区间锁">3.2.3 索引区间锁</a></li></ul></li><li><a href=#33-%e5%8f%af%e4%b8%b2%e8%a1%8c%e5%8c%96%e7%9a%84%e5%bf%ab%e7%85%a7%e9%9a%94%e7%a6%bb-ssi aria-label="3.3 可串行化的快照隔离 SSI">3.3 可串行化的快照隔离 SSI</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-content><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>为了降低应用程序开发人员的心智负担，数据系统提供<strong>事务</strong>这一机制来简化各种各样的常见问题。事务将应用程序的多个读写操作捆绑在一起，称为一个逻辑操作单元。</p><p>执行事务只有两种结果，要么成功要么失败，且失败无副作用，不会产生任何修改；因此，如果失败，那么应用程序可以放心重试。有了事务，应用程序可以不用考虑某些内部潜在的错误以及复杂的并发性问题，这些都由数据库自己来处理，因此又被称之为安全性保证。</p><h2 id=一理解事务>一、理解事务<a hidden class=anchor aria-hidden=true href=#一理解事务>#</a></h2><p>我们知道事务是数据库提供的安全性保证，用于屏蔽数据库内内部的错误以及并发问题，那么这个安全性保证具体包含哪些方面呢？这便是我们常说的 ACID。</p><h3 id=11-acid>1.1 ACID<a hidden class=anchor aria-hidden=true href=#11-acid>#</a></h3><p>ACID，即 Atomicity、Consistency、Isolation 和 Durability。显然，各个数据库能提供的安全性保证是不一样的，因此 ACID 在各个数据库上的表现也会有所区别，但是还是有比较笼统的概念的。</p><h4 id=111-原子性-atomicity>1.1.1 原子性 Atomicity<a hidden class=anchor aria-hidden=true href=#111-原子性-atomicity>#</a></h4><p>想象这样一个场景，客户端发起了包含多个写操作的请求，而这个请求执行到一半时因为各种原因失败了（数据库错误/执行时判断失败），此时客户端该如何继续变成了问题；为了让客户端不用管理请求的执行进度，我们将其包装为一个整体的“原子操作”：如果执行失败，那么数据库必须丢弃或者撤销那些局部完成的修改。</p><p>通过原子性保证，如果事务中止，应用程序可以确定没有实质发生任何更改，所以可以安全地重试（因此又被称为可中止性）。</p><h4 id=112-一致性-consistency>1.1.2 一致性 Consistency<a hidden class=anchor aria-hidden=true href=#112-一致性-consistency>#</a></h4><p>ACID 中的一致性指的是数据层面状态的一致性，例如数据库中 A 的值一定是 B 的值的两倍，那么从满足该一致性的状态开始，执行一个合法的事务后，得到的结果也应满足这个约束。显然，数据之中的约束是应用层定义的，数据库通常只能提供有限的约束工具，例如外键约束和唯一性约束，因此一致性通常是由应用程序本身来维护的。</p><h4 id=113-隔离性-isolation>1.1.3 隔离性 Isolation<a hidden class=anchor aria-hidden=true href=#113-隔离性-isolation>#</a></h4><p>当多个客户端同时使用数据库时，如果访问同一记录，那么便会产生并发问题。为了让应用程序无需考虑并发竞争，数据库提供隔离性保证，这意味着应用执行事务时，从其视角来看所有的事务都是按照顺序在执行的，而数据库也要使用各种机制，确保这些事务在执行完成后所得的结果与顺序执行结果一致，这样才能符合应用的预期；实际中由于性能问题，数据库很少能够提供这样严格的隔离性，因此各个数据库提供的隔离性可能不同。</p><h4 id=114-持久性-durability>1.1.4 持久性 Durability<a hidden class=anchor aria-hidden=true href=#114-持久性-durability>#</a></h4><p>持久性是大部分数据存储系统的基础保证，即数据写入（事务提交）完成后，不管发生什么情况，写入的数据都不应丢失。显然，持久性也是有限，不同数据库所提供的持久性保证都不一样：分布式数据库与单机数据库相比，提供的持久性通常会更好。</p><p>综上所述，原子性保证对于各类数据库来说比较统一；一致性保证与数据库提供的工具有关，且责任在应用层；隔离性保证太过绝对，在各类数据库中都不太一样；持久性保证也很模糊，各类数据库或者说实际情况下都不一样。总而言之，也就原子性比较统一，其他概念在实际实现中都是比较模糊的。</p><h3 id=12-单对象写入与多对象事务>1.2 单对象写入与多对象事务<a hidden class=anchor aria-hidden=true href=#12-单对象写入与多对象事务>#</a></h3><p>在前文提到了 ACID 的安全性保证，在数据库设计中，通常只用关心原子性和隔离性。对于持久性，这是存储系统的基石，无需额外讨论；对于一致性，如果应用提供正确的操作，而数据库保证操作的原子性和隔离性，那么便能保证一致性，因此也不单独讨论，因此我们主要聚焦原子性与隔离性在数据库中的设计和实现。</p><p>接下来我们简单思考一下事务的一些注意事项。</p><h4 id=121-单对象写入>1.2.1 单对象写入<a hidden class=anchor aria-hidden=true href=#121-单对象写入>#</a></h4><p>我们知道，最底层的原子性保证来源于 CPU 的设计，且其只保证了极其有限的操作；对于数据库存储的对象来说，那就更不存在原子性了，因此就算是单对象，其原子性和隔离性也不是天然的：例如数据库写入 100KB 的单对象时，在写的中途也要保证不被读到部分更新的数据（隔离性）；在写的中途失败时，写造成的修改也要能够撤销（原子性）。如果没有单对象的原子性和隔离性保证，那么就更别谈多对象的处理了。</p><p>因此存储引擎在设计时便考虑了单对象的原子性和隔离性的支持，例如使用日志来实现原子性（可恢复可撤销），而使用锁来实现对象的隔离性。因此在我们通常的讨论中，单对象的原子性和隔离性太过基础，我们默认其是底层提供的基础保证，事务（多操作聚合）是在此基础之上的讨论，这也是为什么这部分标题并未称为“单对象事务”。</p><h4 id=122-多对象事务>1.2.2 多对象事务<a hidden class=anchor aria-hidden=true href=#122-多对象事务>#</a></h4><p>在分布式数据库中，多对象事务还是有一定复杂度的，原因在于这些对象可能由于分区存在于不同的子数据库实例中。多对象事务对于一致性的保证有重要的帮助作用，例如同步更新的二级索引、外键引用的有效性、多文档同时更新等。</p><h4 id=123-处理错误与中止>1.2.3 处理错误与中止<a hidden class=anchor aria-hidden=true href=#123-处理错误与中止>#</a></h4><p>前文我们提到事务提供了失败之后可以安全重试的保障，因此对于错误和中止，我们尽量尝试重试，但重试机制还有许多问题需要注意：</p><ol><li>事务执行成功，但应用认为执行失败（各种原因导致未收到成功确认），此时产生的重试可能出现问题：可以提供事务 id 以确保已提交的事务不会重复执行；</li><li>外因中止，例如系统超负荷运行导致事务执行失败，反复重试反而会加重系统负担：设定重试次数上限；</li><li>事务本身操作违反约束导致的失败：应用应调整操作内容而不是继续重试；</li><li>事务只能保证数据库内无副作用，如果有机制与数据库外操作相关，重试可能触发数据库外的副作用，例如更新时发送邮件，重试可能导致多次发送：涉及到多系统事务，可以使用两阶段提交；</li><li>本应进行重试的应用失效，导致重试操作丢失，可能导致数据丢失：应用也要具有持久化的能力。</li></ol><h2 id=二弱隔离级别>二、弱隔离级别<a hidden class=anchor aria-hidden=true href=#二弱隔离级别>#</a></h2><p>接下来我们探讨事务的隔离性，由于这一部分比较复杂，因此单独进行说明。</p><p>前文提到隔离性是为了解决数据库的并发访问问题而抽象出的概念，严格的隔离性使得并发操作执行的结果，与其按照顺序执行的结果一致，这意味着在应用执行事务时，无需关心并发的问题。然而在实际中，这种串行化的隔离性严重限制了数据库的性能，因此通常数据库提供较弱一些的隔离性保证，或是提供一些可选的隔离性配置。</p><p>在非串行化隔离下，总会出现各种各样的问题，我们将问题归纳为以下几种进行标记，并讨论各种隔离级别对这些常见问题的解决：</p><ul><li><sup>A</sup>脏读</li><li><sup>B</sup>脏写</li><li><sup>C</sup>读倾斜</li><li><sup>D</sup>写倾斜</li><li><sup>E</sup>幻读</li><li><sup>F</sup>更新丢失</li></ul><h3 id=21-读-提交>2.1 读-提交<a hidden class=anchor aria-hidden=true href=#21-读-提交>#</a></h3><p>读-提交通常是最基础的隔离级别，它只提供两个保证：</p><ol><li>解决 <strong><sup>A</sup>脏读</strong>：读数据库时，只能看到已成功提交的数据；</li><li>解决 <strong><sup>B</sup>脏写</strong>：写数据库时，只会覆盖已成功提交的数据。</li></ol><p>关于为什么要防止脏读，原因很明显就不再赘述；我们重点关注脏写的问题：</p><p>当有两个事务同时在执行时，前一个事务的写还未提交，而后一个事务想要写数据，如果在未提交的数据上覆盖，则称为脏写，最简单的处理方式是等待直到待写的数据被提交再进行。</p><p>脏写会带来什么问题呢，想象这样一个场景，用户提交的事务需要修改 A、B 两处数据，同时有两个用户提交了事务在执行：</p><p><img alt=脏写 loading=lazy src=/img/dirty_write.svg></p><p>最终导致 A 为用户 2 的数据，B 为用户 1 的数据；脏写会导致不同事务的并发写入最终混杂在一起。</p><h4 id=211-读-提交的实现>2.1.1 读-提交的实现<a hidden class=anchor aria-hidden=true href=#211-读-提交的实现>#</a></h4><p>数据库要实现读-提交，那么就要解决 <strong><sup>A</sup>脏读</strong> 和 <strong><sup>B</sup>脏写</strong>。</p><h5 id=a--的解决>a. <strong><sup>A</sup>脏读</strong> 的解决<a hidden class=anchor aria-hidden=true href=#a--的解决>#</a></h5><p>一种方式是直接加读写锁，一旦数据正在被写入，则排斥读操作，但是这会导致只读事务的执行受阻，严重影响只读事务的响应延迟；因此大多数数据库使用另一种方式来实现：对于每个待更新的对象，数据库都会维护其旧值和当前持锁事务将要设置的新值两个版本，在这个事务提交之前，其他事务读取到的都是旧值，也就防止了 <strong><sup>A</sup>脏读</strong>。</p><h5 id=b--的解决>b. <strong><sup>B</sup>脏写</strong> 的解决<a hidden class=anchor aria-hidden=true href=#b--的解决>#</a></h5><p>显然对于并发写，最简单的方法便是加写锁，数据库通常采用行级锁来防止 <strong><sup>B</sup>脏写</strong>。</p><h3 id=22-快照级别隔离与可重复读>2.2 快照级别隔离与可重复读<a hidden class=anchor aria-hidden=true href=#22-快照级别隔离与可重复读>#</a></h3><p>显然读-提交级别还有解决不了的问题，那便是 <strong><sup>C</sup>读倾斜</strong>。考虑以下场景，用户正在使用事务 T<sub>1</sub> 查询两个账户的总余额，而后台有个程序正在用事务 T<sub>2</sub> 执行两个账户之间的转账：</p><p><img alt=读倾斜 loading=lazy src=/img/read_skew.svg></p><p>T<sub>2</sub> 更新了两个账户的余额，完成转账操作，两个账户的总额不变仍是 200；用户在查询 Account1 的余额时，由于 T<sub>2</sub> 还未提交，因此读取到的是读-提交保证的旧值 100，当其查询 Account2 的余额时，由于 T<sub>2</sub> 已经提交，因此读取到的是新值 200，符合读-提交的隔离性保证，但因此得出的总余额结果却是 300，这便是 <strong><sup>C</sup>读倾斜</strong>，又可称为 <strong><sup>C</sup>不可重复度读</strong>。</p><p><strong><sup>C</sup>读倾斜</strong> 产生的原因是同一个事务内读取到了两个版本的数据，旧的 Account1 和新的 Account2，倘若 T1 在最后添加一个 Account1 的余额查询操作，便会发现前后两次查询操作结果不一致，这便是 <strong><sup>C</sup>不可重复度读</strong> 这个名称的由来。</p><p>在以下场景中 <strong><sup>C</sup>读倾斜</strong> 很有可能发生：</p><ol><li>备份场景：在备份过程中数据库数据在不断更新，备份的数据可能新旧混杂，一致性被破坏；</li><li>分析查询与完整性检查：由于数据在不断更新，这类查询和检查无法实现。</li></ol><p>换个角度来看，事务 T<sub>2</sub> 实际上在 T<sub>1</sub> 执行的过程中，修改了 T<sub>1</sub> 的查询结果（对比正常查询），这使得 T<sub>1</sub> 出现了被称之为 <strong><sup>E</sup>幻读</strong> 的问题。</p><h4 id=221--的解决>2.2.1 <strong><sup>C</sup>读倾斜</strong> 的解决<a hidden class=anchor aria-hidden=true href=#221--的解决>#</a></h4><p>显然，事务在执行过程中应当读取一致的数据（同一个版本的数据），这为我们指明了版本控制这一思路。在读-提交中，为了解决 <strong><sup>A</sup>脏读</strong>，我们维护了数据的新旧值，当写事务为提交时读旧值，提交后读新值；为了解决 <strong><sup>C</sup>读倾斜</strong>，我们要更进一步，就算<strong>写事务已经提交</strong>，其旧值甚至更旧的值仍可能需要维护：有之前正在执行的事务需要读这个数据。</p><p>这意味着旧值不再是一个临时维护的值，而是跟新值一样，是长期需要管理的值；考虑到多个正在进行的事务可能会在不同的时间点查看数据库状态，所以数据库保留了对象多个不同的提交版本，这种技术因此也被称为多版本并发控制（Multi-Version Concurrency Control，MVCC）。</p><p>事务执行在数据库完整的一个版本快照上，因此又被称之为快照级别隔离。当事务执行时，首先赋予一个唯一的、单调递增的事务 ID。每当事务向数据库内写入新内容是，所写的数据都会被标记写入者的事务 ID。</p><p>那么对于一个事务 T<sub>k</sub>，其能访问的数据是哪些版本呢？考虑下图的场景：</p><p><img alt=MVCC loading=lazy src=/img/mvcc.svg></p><p>对于 事务 T<sub>k</sub> 开始时：</p><ol><li>还未提交的事务 T<sub>a</sub>：显然这部分数据不可见；</li><li>中止的事务：由原子性保证这部分数据不可见；</li><li>晚于 T<sub>k</sub> 的事务：显然不可见；</li><li>其他所有写入都应可见。</li></ol><p>简单来说，只有<strong>事务开始</strong>时，数据库内已提交的事务才可见；事务开始后数据的可见性不再变化，形成了“快照”。</p><p>多版本看起来并不复杂，但是要考虑其与数据库其他功能的兼容性，最重要的便是索引与快照级别隔离兼容的处理。</p><h4 id=222-索引与快照级别隔离>2.2.2 索引与快照级别隔离<a hidden class=anchor aria-hidden=true href=#222-索引与快照级别隔离>#</a></h4><p>显然，在多版本数据库中，索引指向的数据有多个版本，最简单的方法便是索引指向所有版本，找出后再根据版本进行过滤；对于使用 B-Tree 的数据库，还可以使用写时复制的技术：</p><p><img alt=copy_on_write loading=lazy src=/img/copy_on_write.png></p><p>如图所示，在 B-Tree 中想要修改 D，写入新数据 D&rsquo;，那么要修改其对应父节点中存储的指针，因此父节点也创建了新版本，同理一直往上，直到创建了新版本的根节点 R&rsquo;。其中不受影响的 B、C 节点及其子节点，在两个树中被共享。</p><p>在每个写入事务开始时创建一个新的版本树，然后在整个事务流程过程中都使用这个新树的根节点开始查找，无论是数据还是索引都是如此；在这个树中所能见到的数据都是这个事务所应该能看到的数据，因此无需进行版本过滤；显然，这些根节点就形成一系列快照。</p><h3 id=23-防止-f更新丢失>2.3 防止 <sup>F</sup>更新丢失<a hidden class=anchor aria-hidden=true href=#23-防止-f更新丢失>#</a></h3><p>就算是快照级别隔离也存在问题没有解决，<strong><sup>F</sup>更新丢失</strong> 便是其中一个。<strong><sup>F</sup>更新丢失</strong> 发生在 read-modify-write 这样的操作流程里，这个流程十分常见，比如：</p><ul><li>计数器：一定是要读取当前值再进行修改</li><li>修改复杂对象的一部分</li></ul><p>广义来说，<strong><sup>F</sup>更新丢失</strong> 也会出现在其他场景，比如 <a href=./brief-notes-about-data-system.md>有关数据系统的一些简要笔记</a> 中的写冲突部分，当两个用户并发写同一个位置的数据时，便会形成写冲突，某些解决方案会最终采用定义上最新的数据，造成 <strong><sup>F</sup>更新丢失</strong>。</p><h4 id=231-原子写操作>2.3.1 原子写操作<a hidden class=anchor aria-hidden=true href=#231-原子写操作>#</a></h4><p>读-修改-写产生的问题不是新问题，此事在经典多线程程序中亦有记载，可以使用原子操作来解决。在多数关系数据库中，简单的 UPDATE 都是并发安全的，是数据库提供的原子更新操作。要实现原子操作，通常采取对读取对象加独占锁的方式来实现，这种技术有时被称为游标稳定性；另一种方式是强制所有的原子操作都在指定的单线程上执行，根据使用场景，这种方式的效率也并不低。</p><h4 id=232-显式加锁>2.3.2 显式加锁<a hidden class=anchor aria-hidden=true href=#232-显式加锁>#</a></h4><p>由于原子操作提供的保证有限，无法适应一些应用层逻辑上的安全保证，因此数据库都提供了常见的锁机制。例如：SELECT &mldr; FOR UPDATE，将满足指定条件的行都选出来，标记为 FOR UPDATE，即加上锁。</p><p>如果数据库没有提供前文提到的原子写操作，用锁也可以很容易自己实现。</p><h4 id=233-自动检测更新丢失>2.3.3 自动检测更新丢失<a hidden class=anchor aria-hidden=true href=#233-自动检测更新丢失>#</a></h4><p>前文提到的两种方式都是把操作串行化来避免 <strong><sup>F</sup>更新丢失</strong>，是一种悲观的策略；实际上，操作并行化，并非一定会出现 <strong><sup>F</sup>更新丢失</strong>，例如一个操作在读-修改-写，另一个操作在读-修改-写到别的位置，实际上并未冲突。因此可以采取一些乐观的策略，比如自动检测更新丢失。</p><p>借助于多版本，我们可以很简单的检测出 <strong><sup>F</sup>更新丢失</strong>：当事务在读-修改-写时，最后写回时发现值的版本更新了，那么说明遇到了冲突，如果写入便会发生 <strong><sup>F</sup>更新丢失</strong>；当检测到后，可以回退事务，并使用原子的更新操作来重新执行。</p><h4 id=234-原子比较和设置>2.3.4 原子比较和设置<a hidden class=anchor aria-hidden=true href=#234-原子比较和设置>#</a></h4><p>熟悉多线程编程便会知道，CAS 原子指令很有用，其实可以看成是弱化版的自动 <strong><sup>F</sup>更新丢失</strong> 检测。自动更新丢失检测是使用版本号来判断，而 CAS 是根据值来判断。</p><p>如果数据库提供了原子性的 CAS 指令，要谨慎使用，原因是多版本技术下，CAS 不一定能检测到版本变化，要注意其适用范围。</p><h4 id=235-冲突解决与复制>2.3.5 冲突解决与复制<a hidden class=anchor aria-hidden=true href=#235-冲突解决与复制>#</a></h4><p>前文提到的方式实际上都是避免冲突发生，从而避免更新丢失的，然而在多副本数据库中，需要加锁的部分可能横跨多个节点，锁的实现需要考虑很多额外的东西；在多主或者无主系统中，甚至无法使用锁，因此只能在冲突发生后来进行解决，可以参照<a href=./brief-notes-about-data-system.md>有关数据系统的一些简要笔记</a>写冲突部分。</p><h3 id=24-d写倾斜>2.4 <sup>D</sup>写倾斜<a hidden class=anchor aria-hidden=true href=#24-d写倾斜>#</a></h3><p>前文介绍了一些隔离级别的常见问题，是比较直接的；但在实际的数据系统中，数据间可能暗含一些约束关系，很容易在对数据的操作中破坏这些关系，造成数据不一致，这便是 <strong><sup>D</sup>写倾斜</strong>。</p><h4 id=241-d写倾斜>2.4.1 <sup>D</sup>写倾斜<a hidden class=anchor aria-hidden=true href=#241-d写倾斜>#</a></h4><p>举一个简单的例子，假设有两个用户同时发起一个事务操作，内容是查询一件物品的空闲情况，如果是空闲则进行预定；我们可以预想到这样一个情况：两个用户都查询了物品的空闲情况，均为可用，因此都进行了预定操作。</p><p>如果预定操作需要修改物品的状态（例如填入预定者信息），那么两个事务尝试更新同一条数据，可能出现前文提到的 <strong><sup>F</sup>更新丢失</strong> 的问题；如果预定操作不需要修改物品的状态，而是在用户各自的数据中进行记录，那么两个事务执行完成后会破坏数据的一致性关系：两个用户都预定了同一件物品，显然是不允许的。这便是 <strong><sup>D</sup>写倾斜</strong>。</p><p>与 <strong><sup>C</sup>读倾斜（不可重复读）</strong> 类似，<strong><sup>D</sup>写倾斜</strong> 发生在事务执行的过程中，操作了不同版本的数据。在 <strong><sup>C</sup>读倾斜</strong> 中比较明显，两次读操作可能读取到的是不同版本的数据，造成了问题；而在 <strong><sup>D</sup>写倾斜</strong> 中，这一关系比较隐含。</p><p>以上文提到的例子来进行说明：物品只能由一个人预定，这一约束实际上将两个用户的数据关联在了一起（同一个物品只能在两个用户数据中出现一次），可以视为一个隐含的整体对象，当然，如果这真的是一个对象的话，两个事务在最后操作时会触发 <strong><sup>F</sup>更新丢失</strong> 的问题，可以通过检查数据版本来进行检测；然而这样一个对象是不存在的，它们只是因约束关系而关联在一起，而版本检测无法在两个对象上进行，当然原子操作也不能在两个对象上进行。</p><p>因此 <strong><sup>D</sup>写倾斜</strong> 实际上是 <strong><sup>F</sup>更新丢失</strong> 的 Max Pro 版本，许多方法在这个问题上失效了。通过总结 <strong><sup>D</sup>写倾斜</strong> 的特征，我们可以发现，问题出现在读-写事务的执行过程中，如果一个事务的写会影响另一个事务的读，那么便<strong>可能</strong>出现 <strong><sup>D</sup>写倾斜</strong>。</p><h4 id=242-d写倾斜的解决>2.4.2 <sup>D</sup>写倾斜的解决<a hidden class=anchor aria-hidden=true href=#242-d写倾斜的解决>#</a></h4><p>前文提到 <strong><sup>D</sup>写倾斜</strong> 之所以比 <strong><sup>F</sup>更新丢失</strong> 复杂，是因为 <strong><sup>D</sup>写倾斜</strong> 的约束关系是隐含的，而 <strong><sup>F</sup>更新丢失</strong> 是显式的；因此我们可以通过显式的约束来避免 <strong><sup>D</sup>写倾斜</strong>，这便是实体化冲突：在数据库中构建具体的对象，这些对象对应具体的隐含约束关系，通过对这些对象加锁来避免 <strong><sup>D</sup>写倾斜</strong>。</p><p>显然，我们把约束关系实例化为数据模型来管理，是十分复杂的，因此在实际中尽量避免使用这一方法；我们还可以使用可串行化隔离来避免 <strong><sup>D</sup>写倾斜</strong>。</p><p>说是避免 <strong><sup>D</sup>写倾斜</strong>，实际上并不是针对 <strong><sup>D</sup>写倾斜</strong> 的，而是通过可串行化隔离来避免所有的并发问题。可串行化隔离是最严格的隔离级别，所有的事务都在一个全局的顺序中执行，因此当然不会出现 <strong><sup>D</sup>写倾斜</strong> 的问题；因此我们在下一节单独对串行化进行探讨。</p><h2 id=三-串行化>三、 串行化<a hidden class=anchor aria-hidden=true href=#三-串行化>#</a></h2><p>事务的并发问题太多了，尤其是最后还碰上了很不好解决的 <strong><sup>D</sup>写倾斜</strong>，弱隔离级别无法解决所有问题；因此我们可以考虑将所有的事务都串行化来避免这些问题，这便是可串行化隔离，是处理事务问题的大招。通过对串行化隔离的思考，大致可以分为以下几种实现方式：</p><ul><li>严格串行执行事务</li><li>两阶段加锁 2PL</li><li>可串行化的快照隔离</li></ul><p>可见串行化也不一定要求严格串行执行，只需保证事务就算并行执行，最终结果与每次一个一个执行的结果相同。</p><h3 id=31-严格串行执行事务>3.1 严格串行执行事务<a hidden class=anchor aria-hidden=true href=#31-严格串行执行事务>#</a></h3><p>这是最直白的想法，在单线程上执行所有的事务；提到单线程，便立马能够联想到 Redis，确实，Redis 便是串行执行解决事务问题的代表之一；单线程严格串行执行，除了能够忽视并发问题外，还避免了大量锁的开销，性能也不会太差。</p><p>显然，这种方案的吞吐量上限是单个 CPU 核的吞吐量，因此更适合搭配主频高的 CPU 使用。</p><blockquote><p>随着 CPU 性能的逐年增长，Redis 的串行执行在大多数情况下不构成瓶颈，反而是接收请求和发送响应的 IO 部分逐渐力不从心了，因此新版本 Redis 进行了多线程改造，但只是在 IO 部分进行了多线程优化，指令（事务）执行仍然是单线程的。</p></blockquote><p>单线程串行执行要求指令必须简洁快速，不然会严重影响后续指令的执行，这意味着活动数据集必须能够完全载入内存，不然事务线程碰到 IO，那么所有指令都要原地等待了。</p><p>同样的，这也意味着单线程串行执行的系统往往不支持交互式的多语句事务，没有办法等待用户交互式地输入指令执行，这会阻塞其他的指令；这里的交互式也包括这种常见场景：应用程序中创建一个事务 TX，然后在 TX 中逐一执行各种逻辑和指令。</p><p>在这样的场景下，应用程序别无选择，只能一次提交整个事务代码交由数据库执行，这便形成了存储过程这一概念。</p><h4 id=311-存储过程>3.1.1 存储过程<a hidden class=anchor aria-hidden=true href=#311-存储过程>#</a></h4><p>显然，就算数据库支持事务并发，如果网络开销较大，也可以使用这种方式进行优化；而且，由于一次性提供了整个事务代码，数据库还能据此进行优化和数据预载等操作；此外，还能预先在数据库中定义存储过程，应用只需调用执行即可。</p><p>由于存储过程本质上是把应用执行的逻辑放到数据库上来执行，因此编写存储过程还需要单独的语言支持，通常是 SQL 的扩展语言，例如 PL/SQL、T-SQL 等，这增加了存储过程使用的门槛；好在许多数据库支持了使用现有的通用编程语言来实现存储过程，例如 Redis 的 Lua 等。</p><p>由于存储过程在数据库服务器上运行，因此在运行时难以进行调试和管理；而数据库通常会连接大量应用使用，本身的性能压力就比较大，存储过程的执行会进一步加重数据库的负担，因此在使用存储过程时，通常需要对其进行性能分析和调优。</p><h4 id=312-分区>3.1.2 分区<a hidden class=anchor aria-hidden=true href=#312-分区>#</a></h4><p>虽然单线程的性能还不错，但如今 CPU 早已不再是单核的时代了，需要想办法利用其余的 CPU 核心来提升性能。为此，我们可以将数据进行分区，让每个分区互相隔离，只在对应的核心上进行事务的执行，这样便能线性地提升数据库的事务性能。</p><p>显然，分区后很有可能遇到一个事务需要跨多个分区的情况，这种情况下便只能将相应分区加锁后执行了，这会造成极大的性能损耗，算是分区的一个缺点；因此分区通常只能使用在简单的键值数据上，如果涉及二级索引，则很有可能跨分区操作造成性能下降。</p><h3 id=32-两阶段加锁-2pl>3.2 两阶段加锁 2PL<a hidden class=anchor aria-hidden=true href=#32-两阶段加锁-2pl>#</a></h3><p>2PL 实际上就是给事务写操作的对象加上互斥锁，因此前文提到的 <strong><sup>D</sup>写倾斜</strong> 便得到了解决：<strong><sup>D</sup>写倾斜</strong> 的前提，便是一个事务的写会影响另一个事务的读，而 2PL 则是通过加锁来避免了这种情况。</p><h4 id=321-2pl-的性能>3.2.1 2PL 的性能<a hidden class=anchor aria-hidden=true href=#321-2pl-的性能>#</a></h4><p>当有许多事务在执行时，由于 2PL 的存在，会出现许多读写锁的使用，很容易出现死锁的情况；因此在使用 2PL 时，通常会使用一些死锁检测机制来避免死锁的发生，这要求数据库能够检测并中止事务的执行</p><p>其次，其主要缺点在于锁的大量使用带来的性能下降；另外，支持事务并发的数据库大多都支持交互式事务，这就意味着事务的执行时间可能很长，如果其获取的锁阻碍了其他事务，很有可能导致其他事务长时间等待；因此在开启 2PL 后数据库的访问延迟有非常大的不确定性。</p><h4 id=322-谓词锁>3.2.2 谓词锁<a hidden class=anchor aria-hidden=true href=#322-谓词锁>#</a></h4><p>2PL 看起来是一个很好的解决方案，但是实际上还有一些问题需要处理：通过快照隔离简单解决掉的 <strong><sup>E</sup>幻读</strong> 问题，2PL 却无法通过对对象加锁来解决。例如一个事务的查询是某个条件下的所有对象，而另一个事务是新增一个满足这个条件的对象，前者无法对不存在的对象加锁，因此其查询结果能够被后者所修改；因此 2PL 需要使用谓词锁来解决这个问题。</p><p>谓词锁是对一个条件的加锁，而不是对一个对象的加锁；例如在上面的例子中，前者可以对满足条件的所有对象加锁，这样便能避免后者的插入操作影响前者的查询结果。具体的，可以在创建对象时检查其是否符合某个谓词锁的条件来实现。</p><h4 id=323-索引区间锁>3.2.3 索引区间锁<a hidden class=anchor aria-hidden=true href=#323-索引区间锁>#</a></h4><p>使用谓词锁时，每次创建对象时，都要挨个检查谓词锁列表，看看是否符合其中某个条件，这会造成性能的下降；因此大多数使用 2PL 的数据库实际上是使用索引区间锁来实现的。</p><p>索引区间锁实际上是对谓词锁的简化，同时为了保证安全性，简化的过程只是将谓词锁的范围扩大了，不会带来额外的风险。</p><p>相较于谓词锁的具体条件，索引区间锁通过对索引的相应范围进行加锁来实现；由于条件通常使用索引进行查询，因此把锁放到索引上，当对象创建，构建相应的索引时便能够检测到。显然索引范围与谓词锁的具体范围是没法完全对应的，不过通过扩大索引加锁范围可以覆盖谓词锁的范围。</p><p>虽然加锁范围变大了，但是检查的开销却小了许多；因此索引区间锁是一个折中的方案。当条件中没有合适的索引可以使用时，便退化为给整个表加锁。</p><h3 id=33-可串行化的快照隔离-ssi>3.3 可串行化的快照隔离 SSI<a hidden class=anchor aria-hidden=true href=#33-可串行化的快照隔离-ssi>#</a></h3><p>前面提到的串行方式，总是想着在一开始就避免问题发生的可能性，确实保证了事务并发安全，但是却带来了性能的严重下降，这是对事务执行的悲观并发控制机制；实际上，就算事务可能操作同一个对象，也不一定会发生冲突，因此我们可以在事务执行时，允许其并发执行，等到最后提交时再进行检查，如果没有冲突则提交，否则回滚。</p><p>这便是可串行化的快照隔离，一种乐观并发控制机制。这要求数据库有能力检测冲突以及中止相应的事务，这也是 SSI 的核心。由于 SSI 基于快照隔离，因此许多问题已经有成熟的解决方案了，我们只需关心如何解决 <strong><sup>D</sup>写倾斜</strong>。</p><p>首先，如果两个事务没有任何关联，那么显然并发执行是安全的；如果两个事务操作的对象有关联，才需要进行冲突判断。经过前文的分析我们知道 <strong><sup>D</sup>写倾斜</strong> 出现于一个事务修改了另一个事务的查询结果，我们针对这一点进行解决。</p><ol><li>从读取者的视角来看，可以检查读取时，对象是否已经有未提交的修改了；</li><li>从写入者的视角来看，可以检查自己写入的对象有没有被其他事务读取过。</li></ol><p>当然，并不需要在检测到时立即终止，因为在提交时有可能冲突已经消失了，因此是否中止放在最后，也就是提交时再进行判断。</p><p>对于情况 1，读取事务注意到有未提交的修改，仍然正常进行执行处理，到最后提交时，如果这个未提交的修改被提交了，说明之前的操作基于过期的数据，因此要进行中止；如果还是处于未提交状态，则无需中止。</p><p>对于情况 2，写入事务需要能够快速检测到相关对象是否有被读取过，因此可以参照索引区间锁的实现，在索引上添加特殊标记，由于冲突不一定发生，因此这个锁不会阻塞该事务的执行，而是关注其状态变化。到最后提交时，如果这个读取事务还未结束（事务还未提交），说明自己的写入会产生冲突，因此要进行中止；如果读取事务已经结束，说明自己的写入不会产生冲突，则可以提交。</p><p>单靠其中一者是无法完成冲突检测的，因此两者同时在进行检测的操作。</p><p>显然，当事务处理的对象较多时，既增大了冲突的可能性，也增大了检测的开销，因此通常要求读-写型事务要简短。总体来讲 SSI 下，执行缓慢事务的影响要更小一些；事务中止的比例会显著影响 SSI 的性能表现。</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>为了降低应用程序的复杂度，数据库提供了事务这一工具，使得应用程序得以放心操作数据而不必考虑许多基础问题；为了满足应用程序的需求（ACID 和性能），数据库支持了事务的并发执行；同时并发执行带来了许多问题，数据库为了解决这些问题，提供了多种隔离级别来满足不同的需求。</p><p>通过对数据系统中这些事务并发问题处理方式的学习，应当能够认识到，在开发过程中随着问题复杂度的提升，通常不会有简单有效的办法能够一劳永逸的解决问题，我们更需要需要多种方案结合使用，并在其带来的性能损耗中进行权衡。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xinrea.cn/tags/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F/>数据系统</a></li><li><a href=https://xinrea.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a></li><li><a href=https://xinrea.cn/tags/%E7%AC%94%E8%AE%B0/>笔记</a></li><li><a href=https://xinrea.cn/tags/%E4%BA%8B%E5%8A%A1/>事务</a></li></ul></footer><script src=https://giscus.app/client.js data-repo=Xinrea/Xinrea.github.io data-repo-id=R_kgDOHCi93A data-category=Announcements data-category-id=DIC_kwDOHCi93M4CqIPv data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://xinrea.cn/>杏仁儿的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>