<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>从 init 函数的顺序问题到 Go 编译器 | 杏仁儿的博客</title>
<meta name=keywords content="Golang,Compiler,Init Function"><meta name=description content="
本文中引用的源码均标注了 Golang 源码仓库链接，branch 为 release-branch.go1.21（本文在编写时 Go 1.21 还未正式发布，正式版可能会有少量变化）。"><meta name=author content><link rel=canonical href=https://xinrea.cn/posts/go-init/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://xinrea.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xinrea.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://xinrea.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://xinrea.cn/apple-touch-icon.png><link rel=mask-icon href=https://xinrea.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://xinrea.cn/posts/go-init/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css integrity=sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js integrity=sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:url" content="https://xinrea.cn/posts/go-init/"><meta property="og:site_name" content="杏仁儿的博客"><meta property="og:title" content="从 init 函数的顺序问题到 Go 编译器"><meta property="og:description" content=" 本文中引用的源码均标注了 Golang 源码仓库链接，branch 为 release-branch.go1.21（本文在编写时 Go 1.21 还未正式发布，正式版可能会有少量变化）。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-21T00:00:00+00:00"><meta property="article:modified_time" content="2023-07-08T11:03:42+00:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Compiler"><meta property="article:tag" content="Init Function"><meta name=twitter:card content="summary"><meta name=twitter:title content="从 init 函数的顺序问题到 Go 编译器"><meta name=twitter:description content="
本文中引用的源码均标注了 Golang 源码仓库链接，branch 为 release-branch.go1.21（本文在编写时 Go 1.21 还未正式发布，正式版可能会有少量变化）。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://xinrea.cn/posts/"},{"@type":"ListItem","position":2,"name":"从 init 函数的顺序问题到 Go 编译器","item":"https://xinrea.cn/posts/go-init/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"从 init 函数的顺序问题到 Go 编译器","name":"从 init 函数的顺序问题到 Go 编译器","description":" 本文中引用的源码均标注了 Golang 源码仓库链接，branch 为 release-branch.go1.21（本文在编写时 Go 1.21 还未正式发布，正式版可能会有少量变化）。\n","keywords":["Golang","Compiler","Init Function"],"articleBody":" 本文中引用的源码均标注了 Golang 源码仓库链接，branch 为 release-branch.go1.21（本文在编写时 Go 1.21 还未正式发布，正式版可能会有少量变化）。\ninit() 在不规范使用情况下产生的现象 在同一个 go 文件里，初始相关操作的执行顺序是 const -\u003e var -\u003e init()。显然，如果同一个文件里有多个 init()，那么将按照声明顺序来执行。\n如果 Package 的 init() 分布在不同的文件里，将会按照什么顺序来执行呢？\n有如下场景：\n1main.go 2a/b.go 3a/c.go 1// main.go 2package main 3 4import \"go-init/a\" 5 6func main() { 7 a.A() 8} 1// a/b.go 2package a 3 4func init() { 5 println(\"b init\") 6} 7 8func A() int { 9 println(\"A\") 10 return 0 11} 1// a/c.go 2package a 3 4func init() { 5 println(\"c init\") 6} 执行 go run main.go，得到输出：\n1b init 2c init 3A 接下来将 a/b.go 改名为 a/d.go，再次执行 go run main.go，输出：\n1c init 2b init 3A 可以看到有 [现象]：a/b.go 和 a/c.go 的 init() 函数的执行顺序是按照文件名的字母顺序来的，将 a/b.go 改名后，其文件名顺序排在了 a/c.go 之后，最终 init() 执行也排在了之后。\n还有更多复杂的情况，例如：\n如果 import 的包之间存在依赖关系，那么这些包的 init() 的执行顺序是怎样的？ 如果 Package 的 init() 分布在不同的文件里，而且这些文件里有交叉依赖的 var 全局变量，那么 init() 和这些全局变量初始化的执行顺序又是怎样的？ 实际上，要真正弄清楚这些，需要深入 Go 编译器，从根源弄清原理。init() 的处理是 Go 编译过程中的重要一环。\n编译的起点 gc.Main() Golang 编译器相关源码位于 go/src/cmd/compile/。\nGo 编译处理的单位是 Package，得到的结果是 Object 文件。在一次编译过程开始时会读取 Package 中所有文件内容进行词法和语法分析。我们很容易就能找到编译器的入口文件 main.go：\n1// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/main.go#L45 2func main() { 3 // disable timestamps for reproducible output 4 log.SetFlags(0) 5 log.SetPrefix(\"compile: \") 6 7 buildcfg.Check() 8 archInit, ok := archInits[buildcfg.GOARCH] 9 if !ok { 10 fmt.Fprintf(os.Stderr, \"compile: unknown architecture %q\\n\", buildcfg.GOARCH) 11 os.Exit(2) 12 } 13 14 gc.Main(archInit) 15 base.Exit(0) 16} gc.Main() 完成了整个编译流程，其内容是本文的重点；编译流程本身比较清晰，但内容很多，在本文中主要关心 init() 相关的处理。\n为了方便理解，请先阅读编译器部分的 README.md，了解编译器的基本流程和相关概念；下面也简单介绍一下编译器的流程，补充一些细节，便于理解为什么 Go 编译器现在是这样一个结构。\n编译流程 1. Parsing 词法和语法分析得到 AST（Abstract Syntax Tree，抽象语法树），每个 AST 等价于一个源文件。关于树的结构和节点的定义见 internal/syntax/nodes.go，Go 源码中的所有元素都能在这里找到对应的结构，极其基础和重要。\n例如：\n1// X[Index[0] : Index[1] : Index[2]] 2SliceExpr struct { 3 X Expr 4 Index [3]Expr 5 // Full indicates whether this is a simple or full slice expression. 6 // In a valid AST, this is equivalent to Index[2] != nil. 7 // TODO(mdempsky): This is only needed to report the \"3-index 8 // slice of string\" error when Index[2] is missing. 9 Full bool 10 expr 11} 我们可以从中知道 slice[:] 操作实际上可以有三个参数，分别表示指针（新起始位置）、长度和容量。\n同时也可以看到 Comments 相关结构仍在开发之中，后续可能会加入 AST 用于生成更加结构化的文档。\n2. Type checking 类型检查，types2 是从 go/types 移植而来的，在这里需要结合发展历史来理解。\n在一开始，Go 的编译器是使用 C 来实现的。到 Go 1.5 版本，实现了自举，其中编译过程中类型检查使用的是 Go 实现的传统检查算法，位于 internal/gc/typecheck.go；同时 Go 1.5 版本在标准库里面加入了 go/types，便于开发者开发 Go 代码分析工具。随着各种代码检查工具的涌现，go/types 发展迅猛，相比较而言，internal/gc/typecheck.go 涉及编译器过于底层，发展较慢。\n直到 Go 1.17 开始开发，需要将泛型作为实验特性加入，此时编译器的类型检查已经无法满足要求，好在 go/types 已经十分成熟，借助其强大的类型推导能力，在编译器中实现了对泛型的处理；这也是 internal/types2 和 go/types 一开始相同的原因。后续对 go/types 问题的修复也应同步到 types2，这样才能保证编译器和代码分析工具的一致性，同时也相当于让更多人参与了编译器的改进；当然，编译器自身也有些特殊需求需要在 types2 中实现。由于现在有两种并行的实现，因此 internal/gc/typecheck.go 被抽取出来，成为了 internal/typecheck 包。\n在 Go 1.5 之前，编译器使用 C 实现，不存在 Go 实现的类型检查。\n在 Go 1.5 - 1.16，编译器使用 Go 实现，类型检查使用 gc/typecheck.go，官方提供了 go/types 包。\n在 Go 1.17 时泛型还只是可选项，因此编译器提供了参数 -G 来选择是否开启泛型，实际上，当 G=0 时编译器会使用旧的 typecheck 来进行类型检查；当 G=3 时使用 types2 （go/types移植而来）进行类型检查以支持泛型。\n在 Go 1.18 正式推出泛型以后，-G 参数仍然存在，只不过默认值改成了 G=3，也就是说，现在编译器默认使用 types2 进行类型检查。\n在 Go 1.19 推出后，-G 参数被移除，编译器只能使用 types2 进行类型检查。\n例如 Commit: 8fd2875：\n修改 src/go/types 后，也同步修改了 src/cmd/compile/internal/types2 下的内容。\n3. IR construction(“noding”) IR（Intermediate Representation，中间表示）是一种介于 AST 和汇编代码之间的表示，是一种更加抽象的表示，能够更好地表示语义。这一步就是将 AST 转换为 IR，这个过程称作 noding。\n在 Go 1.17 之前，并没有 IR 的概念，或者说有，但是还不叫 IR。\n在 Go 1.17，当 G=0 时，编译器可选择使用 internal/typecheck 进行类型检查，因此对应使用 noder 进行 noding；当 G=3 时，编译器使用 types2 进行类型检查，因此使用相应的新实现来进行 noding， 称之为 noder2。\n在 Go 1.18，同样可以通过 -G 参数来选择使用 internal/typecheck 或者 types2 进行类型检查，因此 noder 和 noder2 仍然是并存的。\n在 Go 1.19 之后，编译器只能使用 types2 进行类型检查，因此 noder2 也是唯一的 noding 实现。\n其实 IR 也是一种形式的 AST，被称为 GC AST（Go Compiler AST）。那么为什么要转换呢？主要原因是自 Go 1.5 实现自举时，参考旧 C 的实现来完成了 AST 上的类型检查等等后续操作；但是新的 Go 实现的词法语法分析得到的 AST 只是分别与源文件对应，还未处理 import 以及合并，并不完整；好在这个转换并不复杂。\n旧的处理流程如下所示：\n1// 旧处理流程 Go 1.5 - 1.16 2[AST1,AST2,...] := Parse([file1,file2,...]) 3 4// 处理 import，合并 AST 5IR := Noder([AST1,AST2,...]) 6 7// 类型检查 8Typecheck(IR) 9MiddleEndOP(IR) 10SSA := SSAGen(IR) 11MACHINE_CODE := CodeGen(SSA) 在 Go 1.17 引入 types2 后，由于 types2 是作用于 AST 上的，因此新的处理流程变成了：\n1// 新处理流程 Go 1.17 2[AST1,AST2,...] := Parse([file1,file2,...]) 3 4#if G=3 5 // 处理 import，类型检查，处理泛型 6 TypeInfo := Types2([AST1,AST2,...]) 7 IR := Noder2([AST1,AST2,...],TypeInfo) 8#elseif G=0 9 // 处理 import，合并 AST 10 IR := Noder([AST1,AST2,...]) 11#endif 12 13// 之后完全一致 14Typecheck(IR) 15MiddleEndOp(IR) 16SSA := SSAGen(IR) 17MACHINE_CODE := CodeGen(SSA) noder2 的实现位于 internal/ir。会发现当 G=3 时，虽然用了 internal/types2 来进行类型检查，但是后续在 IR 上还是跑了一遍 internal/typecheck，在这里有许多原因，主要是 internal/typecheck 会对 IR 进行一些修改调整，因此还需要保留，详情可以看这里的注释：internal/noder/unified.go#L51。\n在 Go 1.18 又引入了 Unified IR（GOEXPERIMENT=unified 开启），于是乎三种流程并行存在：\n1// 新处理流程 Go 1.18 2[AST1,AST2,...] := Parse([file1,file2,...]) 3 4#if Unified 5 IR := Unified([AST1,AST2,...]) 6#else 7 #if G=3 8 // 处理 import，类型检查，处理泛型 9 TypeInfo := Types2([AST1,AST2,...]) 10 IR := Noder2([AST1,AST2,...],TypeInfo) 11 #elseif G=0 12 // 处理 import，合并 AST 13 IR := Noder([AST1,AST2,...]) 14 #endif 15 Typecheck(IR) 16#endif 17 18MiddleEndOp(IR) 19SSA := SSAGen(IR) 20MACHINE_CODE := CodeGen(SSA) 在 Go 1.19 移除了 G=0 的流程：\n1// 新处理流程 Go 1.19 2[AST1,AST2,...] := Parse([file1,file2,...]) 3 4#if Unified 5 IR := Unified([AST1,AST2,...]) 6#else 7 // 处理 import，类型检查，处理泛型 8 TypeInfo := Types2([AST1,AST2,...]) 9 IR := Noder2([AST1,AST2,...],TypeInfo) 10 Typecheck(IR) 11#endif 12 13MiddleEndOp(IR) 14SSA := SSAGen(IR) 15MACHINE_CODE := CodeGen(SSA) 在 Go 1.21 正式启用了 Unified IR，因此 unified 也就是唯一的 noding 实现了，确实实现了统一，欢迎来到 Go 1.21 ！（实际上需要处理的东西其实没有改变，只是整合在了 Unified 内，因此原来的包还依然存在）\n1// 新处理流程 Go 1.21 2[AST1,AST2,...] := Parse([file1,file2,...]) 3 4IR := Unified([AST1,AST2,...]) 5 6MiddleEndOp(IR) 7SSA := SSAGen(IR) 8MACHINE_CODE := CodeGen(SSA) 下面是各种 noder 在不同版本的存在状态：\nGo 1.17 之前：noder Go 1.17: noder, noder2 Go 1.18: noder, noder2, unified Go 1.19: noder2, unified Go 1.20: noder2, unified Go 1.21: unified 4. Middle end internal/deadcode (dead code elimination) internal/inline (function call inlining) internal/devirtualize (devirtualization of known interface method calls) internal/escape (escape analysis) 5. Walk，SSA Gen 以及机器码生成 Walk 遍历 IR，拆分复杂的语句以及将语法糖转换成基础的语句 SSA Gen 将 IR 转化为 Static Single Assignment (SSA) 形式，此时还与具体的机器无关 机器码生成会根据架构以及更多机器相关的信息，对 SSA 进行优化；同时进行栈帧分配，寄存器分配，指针存活分析等等，最终经过汇编器 cmd/internal/obj 生成机器码。 流程中 init 相关的处理 前面我们了解了 Go 编译器的流程，以及其发展变化的历史。接下来我们来看看其中 init 相关的具体处理。\n1// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/gc/main.go#L59 2// Main parses flags and Go source files specified in the command-line 3// arguments, type-checks the parsed Go package, compiles functions to machine 4// code, and finally writes the compiled package definition to disk. 5func Main(archInit func(*ssagen.ArchInfo)) { 6 ... 7 // Parse and typecheck input. 8 noder.LoadPackage(flag.Args()) 9 ... 10 // Create \"init\" function for package-scope variable initialization 11 // statements, if any. 12 // 13 // Note: This needs to happen early, before any optimizations. The 14 // Go spec defines a precise order than initialization should be 15 // carried out in, and even mundane optimizations like dead code 16 // removal can skew the results (e.g., #43444). 17 pkginit.MakeInit() 18 ... 19 // Build init task, if needed. 20 if initTask := pkginit.Task(); initTask != nil { 21 typecheck.Export(initTask) 22 } 23 ... gc.Main() 流程中主要有以上三部分对 init 进行了处理，接下来我们分别看看这三部分。\nnoder.LoadPackage() 1// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/noder/noder.go#L27 2func LoadPackage(filenames []string) { 3 ... 4 noders := make([]*noder, len(filenames)) 5 ... 6 go func() { 7 for i, filename := range filenames { 8 ... 9 go func() { 10 ... 11 f, err := os.Open(filename) 12 ... 13 p.file, _ = syntax.Parse(fbase, f, p.error, p.pragma, syntax.CheckBranches) // errors are tracked via p.error 14 }() 15 } 16 }() 17 ... 18 unified(m, noders) 19} 可以看到 LoadPackage() 会并行的对每个文件进行读取以及词法语法分析，构建 AST。并将得到的 AST 列表传递给 unified() 进行统一处理。\n1// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/noder/unified.go#L71 2func unified(m posMap, noders []*noder) { 3 ... 4 data := writePkgStub(m, noders) 5 ... 6 target := typecheck.Target 7 r := localPkgReader.newReader(pkgbits.RelocMeta, pkgbits.PrivateRootIdx, pkgbits.SyncPrivate) 8 r.pkgInit(types.LocalPkg, target) 9 10 // 后面均为 `internal/typecheck` 的处理，与 init 无关 11 // Type-check any top-level assignments. We ignore non-assignments 12 // here because other declarations are typechecked as they're 13 // constructed. 14 for i, ndecls := 0, len(target.Decls); i \u003c ndecls; i++ { 15 switch n := target.Decls[i]; n.Op() { 16 case ir.OAS, ir.OAS2: 17 target.Decls[i] = typecheck.Stmt(n) 18 } 19 } 20 21 readBodies(target, false) 22 23 // Check that nothing snuck past typechecking. 24 for _, n := range target.Decls { 25 if n.Typecheck() == 0 { 26 base.FatalfAt(n.Pos(), \"missed typecheck: %v\", n) 27 } 28 29 // For functions, check that at least their first statement (if 30 // any) was typechecked too. 31 if fn, ok := n.(*ir.Func); ok \u0026\u0026 len(fn.Body) != 0 { 32 if stmt := fn.Body[0]; stmt.Typecheck() == 0 { 33 base.FatalfAt(stmt.Pos(), \"missed typecheck: %v\", stmt) 34 } 35 } 36 } 37 ... 38} 其中 writePkgStub() 完成了类型检查。接下来的调用链有点长，在这里就不放源代码了，大致流程如下：\nwritePkgStub() -\u003e noder.checkFiles -\u003e conf.Check() -\u003e Checker.Files() -\u003e check.checkFiles()\n1// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/types2/check.go#L335 2func (check *Checker) checkFiles(files []*syntax.File) (err error) { 3 ... 4 print(\"== initFiles ==\") 5 check.initFiles(files) 6 7 print(\"== collectObjects ==\") 8 check.collectObjects() 9 10 print(\"== packageObjects ==\") 11 check.packageObjects() 12 13 print(\"== processDelayed ==\") 14 check.processDelayed(0) // incl. all functions 15 16 print(\"== cleanup ==\") 17 check.cleanup() 18 19 print(\"== initOrder ==\") 20 check.initOrder() 21 ... 22} initFiles() 用于检查文件开头的 package 语句所声明的名称是否符合要求，例如要跟当前 package 名一致，否则忽略这个文件（都经过词法语法分析了，白分析了，当然编译前就能检查出这些问题，一般不会进行到这里才发现）。\ncollectObjects() 在此处对 import 的 Package 进行了加载，并将其置于相应的 Scope 中。可以看到这里仍然是按照文件顺序在进行处理，通过 check.impMap 来缓存已经加载的 Package；同时用 pkgImports map[*Package]bool 来记录本 Package 已经引用的 Package，避免其重复加入 pkg.imports 数组。\n同时，还能从中看到一些特殊 import 的处理，例如 import . 和 import _ 以及别名。DotImport 会将 imported package 中的导出符号全部遍历导入到当前的 FileScope 中，而一般情况下是将 imported package 整个加入到当前的 FileScope 中，这样会有额外的层次结构。\n注意这里提到了 FileScope，我们知道在 Go 的同一个 Package 下，许多声明是不存在 FileScope 的，例如全局变量在一个文件中声明，另一个文件中可以直接使用；同名也会发生冲突，因为这些都在同一个 PackageScope 下。但是对于 import 操作来说，每个文件都有自己需要 import 的内容，因此需要一个 FileScope 来记录区分这些信息。\nScope 结构组织好后，还需要检查 FileScope 跟 PackageScope 之间的冲突问题，这主要是 DotImport 导致的。\n1// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/types2/resolver.go#L472 2// verify that objects in package and file scopes have different names 3for _, scope := range fileScopes { 4 for name, obj := range scope.elems { 5 if alt := pkg.scope.Lookup(name); alt != nil { 6 ... initOrder() 是对一些有依赖关系的全局声明进行排序，并未涉及 init 的处理，例如：\n1var ( 2 // a depends on b and c, c depends on f 3 a = b + c 4 b = 1 5 c = f() 6 7 // circular dependency 8 d = e 9 e = d 10) 在 Go 中，能够被用于初始化表达式的对象被称为 Dependency 对象，有 Const, Var, Func 这三类。先构建对象依赖关系的有向图（Directed Graph），再以每个节点的依赖数目为权重构建最小堆（MinHeap）并以此堆作为最小优先级队列（PriorityQueue），因此队列头部的对象总是依赖其它对象最少的，所以该队列的遍历顺序就是初始化的顺序，是很常规的处理思路。要注意常量的初始化比较简单，在构建时就已经确定，在这里仍然加入是为了检测循环依赖。\n1https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/noder/unified.go#L209 2func writePkgStub(m posMap, noders []*noder) string { 3 // 类型检查 4 pkg, info := checkFiles(m, noders) 5 6 pw := newPkgWriter(m, pkg, info) 7 pw.collectDecls(noders) 8 ... 9 var sb strings.Builder 10 pw.DumpTo(\u0026sb) 11 12 // At this point, we're done with types2. Make sure the package is 13 // garbage collected. 14 freePackage(pkg) 15 16 return sb.String() 17} 最后再回到开始，可见 writePkgStub 包含了 internal/types2 的类型检查；类型检查会涉及到外部包的导出类型，也就是说会处理 import 语句；同时，类型检查的过程中也生成了一份 types2.Package 以及 types2.info，其中 types2.package 包含 Scope 层次信息以及每个 Scope 中的 Object 信息；types2.info 包含了类型检查中生成的类型信息；最后通过 pkgWriter 将这两个信息整合序列化为字符串，也就是最终得到的 data。\n实际上，这个 data 就是 Unified IR 的导出；接下来使用 pkgReader 将 data 重新构建为 IR，存储在 typecheck.Target。\n明明步骤紧接在一起，为什么要把 Unified IR 先 export 再 import 呢？ 这样做主要是为了将 Unified IR 与后续部分完全解耦，可以看到只要有 export data 就能够完成后续的编译工作；同时通过实现不同的 pkgReader，便可以从 export data 中提取出不同的信息。例如编译器需要从中读取完整的 IR； x/tools 下的工具需要对代码进行静态分析，那么就可以实现一个 pkgReader 来提取自己需要的信息，而不必再自己实现一遍词法语法分析以及类型检查。\n在 pkgReader 构建 IR 的过程中，遇到函数类型的 Object 时，做了如下处理：\n1// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/noder/reader.go#L750 2case pkgbits.ObjFunc: 3 if sym.Name == \"init\" { 4 sym = Renameinit() 5 } 6... 可见 init 函数是多么特殊，它会被重命名，这样就不会与其他 init 函数冲突了。Renameinit() 的实现如下：\n1// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/noder/noder.go#L419 2var renameinitgen int 3 4func Renameinit() *types.Sym { 5 s := typecheck.LookupNum(\"init.\", renameinitgen) 6 renameinitgen++ 7 return s 8} 可见只是给了个编号，重命名成了一系列 init.0 init.1 init.2 等等的函数。\n至此 LoadPackage() 的工作就完成了。\npkginit.MakeInit() 接下来终于来到了 pkginit 包的内容。\n1// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/gc/main.go#L59 2// Main parses flags and Go source files specified in the command-line 3// arguments, type-checks the parsed Go package, compiles functions to machine 4// code, and finally writes the compiled package definition to disk. 5func Main(archInit func(*ssagen.ArchInfo)) { 6 ... 7 // Parse and typecheck input. 8 noder.LoadPackage(flag.Args()) 9 ... 10 // Create \"init\" function for package-scope variable initialization 11 // statements, if any. 12 // 13 // Note: This needs to happen early, before any optimizations. The 14 // Go spec defines a precise order than initialization should be 15 // carried out in, and even mundane optimizations like dead code 16 // removal can skew the results (e.g., #43444). 17 pkginit.MakeInit() 18 ... 19 // Build init task, if needed. 20 if initTask := pkginit.Task(); initTask != nil { 21 typecheck.Export(initTask) 22 } 23 ... 从注释也可以知道，在词法分析、语法分析以及类型检查和构造 IR 树的过程中，均未涉及代码优化。以下是 MakeInit() 的内容，关键部分使用中文进行了更详细的注释，可以对照相关方法的源码进行阅读。\n1// TODO(mdempsky): Move into noder, so that the types2-based frontends 2// can use Info.InitOrder instead. 3func MakeInit() { 4 // Init 相关的处理只涉及全局声明（Package Level），依赖关系作为有向边来构建有向图，然后进行拓扑排序。 5 nf := initOrder(typecheck.Target.Decls) 6 if len(nf) == 0 { 7 return 8 } 9 10 // Make a function that contains all the initialization statements. 11 base.Pos = nf[0].Pos() // prolog/epilog gets line number of first init stmt 12 // 查找 init 符号，如果 Package 的全局符号中没有则创建；不用担心 init 符号已经被用户的 init 函数使用，因为 IR 树在生成过程中遇到 init 会重命名为 init.0 init.1 这样的格式，前面提到 g.generate() 的时候也有说明。 13 initializers := typecheck.Lookup(\"init\") 14 /* 用 init 符号声明一个新的函数，用于存放所有的初始化工作。具体实现是：此处在 IR 树中对应位置建立了新的 ONAME Node（ONAME 表示 var/func name），类型指定为 PFUNC，同时也将符号表中的 init 更新为 symFunc，表明这个符号是函数名；然后新建一个函数节点，将 ONAME Node 指向函数节点，最后将函数节点返回。 15 */ 16 fn := typecheck.DeclFunc(initializers, nil, nil, nil) 17 // 类型检查过程中生成了一个 InitTodoFunc，其作为全局初始化语句的临时上下文环境。现在将临时环境 InitTodoFunc 的内容转移到 fn。 18 for _, dcl := range typecheck.InitTodoFunc.Dcl { 19 dcl.Curfn = fn 20 } 21 fn.Dcl = append(fn.Dcl, typecheck.InitTodoFunc.Dcl...) 22 typecheck.InitTodoFunc.Dcl = nil 23 24 // Suppress useless \"can inline\" diagnostics. 25 // Init functions are only called dynamically. 26 fn.SetInlinabilityChecked(true) 27 28 // 配置函数体。 29 fn.Body = nf 30 typecheck.FinishFuncBody() 31 32 // 确定 fn 为函数节点 33 typecheck.Func(fn) 34 // 在 fn 的内部上下文环境下检查函数体 35 ir.WithFunc(fn, func() { 36 typecheck.Stmts(nf) 37 }) 38 // 把函数加入到 Package 的全局声明列表。 39 typecheck.Target.Decls = append(typecheck.Target.Decls, fn) 40 41 // Prepend to Inits, so it runs first, before any user-declared init 42 // functions. 43 typecheck.Target.Inits = append([]*ir.Func{fn}, typecheck.Target.Inits...) 44 45 if typecheck.InitTodoFunc.Dcl != nil { 46 // We only generate temps using InitTodoFunc if there 47 // are package-scope initialization statements, so 48 // something's weird if we get here. 49 base.Fatalf(\"InitTodoFunc still has declarations\") 50 } 51 typecheck.InitTodoFunc = nil 52} 旧版本中 MakeInit() 的工作是在 pkginit.Task() 中实现的，现在被抽取了出来，原因有以下几点。\n首先，MakeInit() 负责初始化函数的创建并插入 typecheck.Target.Inits，pkginit.Task() 得到了简化，毕竟这个初始化函数和其他用户定义的 init 实际上没有本质区别。\n其次，敏锐的同学可能发现了，类型检查的过程中，已经进行了一次 initOrder()，但只检查了循环依赖的问题；这次又 initOrder() 显得有些冗余。因此将这一部分从 Task() 中拆分出来，希望以后能够放到类型检查的过程中，避免重复的排序操作。当前抽离成了单独的函数但是还未并入类型检查，处于中间状态，可见不久后将会并入类型检查，注释中的 TODO 就是在说这个问题。\n最后，初始化函数如果在 Task() 中创建，则无法参与到类型检查结束到 Task() 开始这之间的优化过程，主要包括无效代码清理和内联优化。因此将其提前到类型检查结束后创建，这样就可以参与到优化过程中了。\npkginit.Task() 最后，终于来到了 init 处理的终点， pkginit.Task()。\n1// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/pkginit/init.go#L93 2// Task makes and returns an initialization record for the package. 3// See runtime/proc.go:initTask for its layout. 4// The 3 tasks for initialization are: 5// 1. Initialize all of the packages the current package depends on. 6// 2. Initialize all the variables that have initializers. 7// 3. Run any init functions. 8func Task() *ir.Name { 9 ... 10 // Find imported packages with init tasks. 11 // 这里可以看出 Package 最终的初始化任务被合并在了 .inittask 这个结构体中，因此对于引用的包才能这样进行查找，此处还检查了 .inittask 结构体是否合法。最终加入到 deps 数组。 12 for _, pkg := range typecheck.Target.Imports { 13 n := typecheck.Resolve(ir.NewIdent(base.Pos, pkg.Lookup(\".inittask\"))) 14 if n.Op() == ir.ONONAME { 15 continue 16 } 17 if n.Op() != ir.ONAME || n.(*ir.Name).Class != ir.PEXTERN { 18 base.Fatalf(\"bad inittask: %v\", n) 19 } 20 deps = append(deps, n.(*ir.Name).Linksym()) 21 } 22 ... 23 // 如果开启了 Address Sanitizer，那么需要在创建一个 init 函数加入 typecheck.Target.Inits，用于初始化 ASan 相关的全局变量。 24 if base.Flag.ASan { 25 ... 26 // 可见这个 init 将会在最后执行 27 typecheck.Target.Inits = append(typecheck.Target.Inits, fnInit) 28 } 29 ... 30 // Record user init functions. 31 for _, fn := range typecheck.Target.Inits { 32 // 只有处理 Package 全局变量的才叫 init，其它的都被重命名为了 init.0、init.1 等。 33 if fn.Sym().Name == \"init\" { 34 // Synthetic init function for initialization of package-scope 35 // variables. We can use staticinit to optimize away static 36 // assignments. 37 s := staticinit.Schedule{ 38 Plans: make(map[ir.Node]*staticinit.Plan), 39 Temps: make(map[ir.Node]*ir.Name), 40 } 41 for _, n := range fn.Body { 42 s.StaticInit(n) 43 } 44 fn.Body = s.Out 45 ir.WithFunc(fn, func() { 46 typecheck.Stmts(fn.Body) 47 }) 48 49 if len(fn.Body) == 0 { 50 fn.Body = []ir.Node{ir.NewBlockStmt(src.NoXPos, nil)} 51 } 52 } 53 54 // Skip init functions with empty bodies. 55 if len(fn.Body) == 1 { 56 if stmt := fn.Body[0]; stmt.Op() == ir.OBLOCK \u0026\u0026 len(stmt.(*ir.BlockStmt).List) == 0 { 57 continue 58 } 59 } 60 fns = append(fns, fn.Nname.Linksym()) 61 } 最终 fns 数组保存了所有 init 函数；deps 数组保存了所有依赖的包的 .inittask 结构体。接下来合并构建自己 Package 的 .inittask。\n1// Make an .inittask structure. 2sym := typecheck.Lookup(\".inittask\") 3task := typecheck.NewName(sym) 4// 显然这个 .inittask 不是 uint8 类型的，只是为了占位，因此这里设置了一个 fake type。 5task.SetType(types.Types[types.TUINT8]) // fake type 6task.Class = ir.PEXTERN 7sym.Def = task 8lsym := task.Linksym() 9ot := 0 10// lsym.P = [0] 11ot = objw.Uintptr(lsym, ot, 0) // state: not initialized yet 12// lsym.P = [0, len(deps)] 13ot = objw.Uintptr(lsym, ot, uint64(len(deps))) 14// lsym.P = [0, len(deps), len(fns)] 15ot = objw.Uintptr(lsym, ot, uint64(len(fns))) 16// lsym.R = [newR(d)...] 17for _, d := range deps { 18 ot = objw.SymPtr(lsym, ot, d, 0) 19} 20// lsym.R = [newR(d)..., newR(f)...] 21for _, f := range fns { 22 ot = objw.SymPtr(lsym, ot, f, 0) 23} 24// An initTask has pointers, but none into the Go heap. 25// It's not quite read only, the state field must be modifiable. 26// 此处说明这个 .inittask 符号是全局的，决定了最后在 object 文件中的位置区域。 27objw.Global(lsym, int32(ot), obj.NOPTR) 28return task 在最后将其设置为导出的（Export），因为其符号名并非大写字母开头，但是要被其他包使用：\n1// Build init task, if needed. 2if initTask := pkginit.Task(); initTask != nil { 3 typecheck.Export(initTask) 4} 至此，Package 单元对于 init 的处理就结束了，最后 Package 被编译为带有 .inittask 表的 object 文件，这个表中包含了所有的 init.x 函数和依赖的包的 .inittask 结构体指针，要注意这里只知道符号之间的关系，其他包里 init 函数的具体实现是不知道的，需要在链接阶段处理。\n链接时，在拥有了所有的 .inittask 包含的具体函数相关信息后，链接器会将其按照依赖关系进行排序，生成一个具体的 mainInittasks 列表供 runtime 使用。此处不再展开这一部分，有兴趣的同学可以自行阅读链接器 inittask 部分的源码：src/cmd/link/internal/ld/inittask.go，最终 SymbolName 为 go:main.inittasks。\n最终链接生成可执行文件时，inittasks 的地址会给到 src/runtime/proc.go 的 runtime_inittasks 数组变量，然后在runtime.main 函数中被使用：\n1// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/runtime/proc.go#L144 2func main() { 3 ... 4 doInit(runtime_inittasks) // Must be before defer. 5 ... 6} 最后回看一开始发现的现象：\n[现象]：a/b.go 和 a/c.go 的 init() 函数的执行顺序是按照文件名的字母顺序来的，将 a/b.go 改名后，其文件名顺序排在了 a/c.go 之后，最终 init() 执行也排在了之后。\n根源在于编译器在读取源文件时是按照文件系统文件名顺序读入，在处理时也是依文件次序处理的，也就是编译器遇到 init 和 import 的顺序都是由文件名顺序决定的。\n虽然有 initOrder() 的存在，但是它不会影响用户定义的 init() 的顺序\ninitOrder() 会处理 import 的依赖关系，因此最终各个 Package 的 init 顺序时根据依赖关系决定的。\n例如：\n1// a1.go 2import \"b\" 1// a2.go 2import \"c\" 1// b.go 2import \"c\" 那么不管 a1.go 和 a2.go 的文件名顺序如何，package c 都会先于 package b 初始化，因为 b 依赖 c。\n","wordCount":"7730","inLanguage":"en","datePublished":"2023-06-21T00:00:00Z","dateModified":"2023-07-08T11:03:42Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://xinrea.cn/posts/go-init/"},"publisher":{"@type":"Organization","name":"杏仁儿的博客","logo":{"@type":"ImageObject","url":"https://xinrea.cn/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xinrea.cn/ accesskey=h title="杏仁儿的博客 (Alt + H)">杏仁儿的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xinrea.cn/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://xinrea.cn/tags title=Tags><span>Tags</span></a></li><li><a href=https://xinrea.cn/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://xinrea.cn/projects title=Projects><span>Projects</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://xinrea.cn/>Home</a>&nbsp;»&nbsp;<a href=https://xinrea.cn/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">从 init 函数的顺序问题到 Go 编译器</h1><div class=post-meta><span title='2023-06-21 00:00:00 +0000 UTC'>June 21, 2023</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;7730 words&nbsp;|&nbsp;<a href=https://github.com/Xinrea/Xinrea.github.io/tree/main/content/posts/go-init.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#init-%e5%9c%a8%e4%b8%8d%e8%a7%84%e8%8c%83%e4%bd%bf%e7%94%a8%e6%83%85%e5%86%b5%e4%b8%8b%e4%ba%a7%e7%94%9f%e7%9a%84%e7%8e%b0%e8%b1%a1 aria-label="init() 在不规范使用情况下产生的现象">init() 在不规范使用情况下产生的现象</a></li><li><a href=#%e7%bc%96%e8%af%91%e7%9a%84%e8%b5%b7%e7%82%b9-gcmain aria-label="编译的起点 gc.Main()">编译的起点 gc.Main()</a></li><li><a href=#%e7%bc%96%e8%af%91%e6%b5%81%e7%a8%8b aria-label=编译流程>编译流程</a><ul><li><a href=#1-parsing aria-label="1. Parsing">1. Parsing</a></li><li><a href=#2-type-checking aria-label="2. Type checking">2. Type checking</a></li><li><a href=#3-ir-construction aria-label="3. IR construction(&ldquo;noding&rdquo;)">3. IR construction(&ldquo;noding&rdquo;)</a></li><li><a href=#4-middle-end aria-label="4. Middle end">4. Middle end</a></li><li><a href=#5-walkssa-gen-%e4%bb%a5%e5%8f%8a%e6%9c%ba%e5%99%a8%e7%a0%81%e7%94%9f%e6%88%90 aria-label="5. Walk，SSA Gen 以及机器码生成">5. Walk，SSA Gen 以及机器码生成</a></li></ul></li><li><a href=#%e6%b5%81%e7%a8%8b%e4%b8%ad-init-%e7%9b%b8%e5%85%b3%e7%9a%84%e5%a4%84%e7%90%86 aria-label="流程中 init 相关的处理">流程中 init 相关的处理</a><ul><li><a href=#noderloadpackage aria-label=noder.LoadPackage()>noder.LoadPackage()</a></li><li><a href=#pkginitmakeinit aria-label=pkginit.MakeInit()>pkginit.MakeInit()</a></li><li><a href=#pkginittask aria-label=pkginit.Task()>pkginit.Task()</a></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>本文中引用的源码均标注了 Golang 源码仓库链接，branch 为 <code>release-branch.go1.21</code>（本文在编写时 Go 1.21 还未正式发布，正式版可能会有少量变化）。</p></blockquote><h2 id=init-在不规范使用情况下产生的现象><code>init()</code> 在不规范使用情况下产生的现象<a hidden class=anchor aria-hidden=true href=#init-在不规范使用情况下产生的现象>#</a></h2><p>在同一个 go 文件里，初始相关操作的执行顺序是 <code>const</code> -> <code>var</code> -> <code>init()</code>。显然，如果同一个文件里有多个 <code>init()</code>，那么将按照声明顺序来执行。</p><p>如果 Package 的 <code>init()</code> 分布在不同的文件里，将会按照什么顺序来执行呢？</p><p>有如下场景：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>main.go
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>a/b.go
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>a/c.go
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#75715e>// main.go</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;go-init/a&#34;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>    <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>A</span>()
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8</span><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#75715e>// a/b.go</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>a</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    println(<span style=color:#e6db74>&#34;b init&#34;</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>A</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    println(<span style=color:#e6db74>&#34;A&#34;</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#75715e>// a/c.go</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>a</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>    println(<span style=color:#e6db74>&#34;c init&#34;</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>}
</span></span></code></pre></div><p>执行 <code>go run main.go</code>，得到输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>b init
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>c init
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>A
</span></span></code></pre></div><p>接下来将 <code>a/b.go</code> 改名为 <code>a/d.go</code>，再次执行 <code>go run main.go</code>，输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>c init
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>b init
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>A
</span></span></code></pre></div><p>可以看到有 [现象]：<code>a/b.go</code> 和 <code>a/c.go</code> 的 <code>init()</code> 函数的执行顺序是按照文件名的字母顺序来的，将 <code>a/b.go</code> 改名后，其文件名顺序排在了 <code>a/c.go</code> 之后，最终 <code>init()</code> 执行也排在了之后。</p><p>还有更多复杂的情况，例如：</p><ul><li>如果 import 的包之间存在依赖关系，那么这些包的 <code>init()</code> 的执行顺序是怎样的？</li><li>如果 Package 的 <code>init()</code> 分布在不同的文件里，而且这些文件里有交叉依赖的 <code>var</code> 全局变量，那么 <code>init()</code> 和这些全局变量初始化的执行顺序又是怎样的？</li></ul><p>实际上，要真正弄清楚这些，需要深入 Go 编译器，从根源弄清原理。<code>init()</code> 的处理是 Go 编译过程中的重要一环。</p><h2 id=编译的起点-gcmain>编译的起点 <code>gc.Main()</code><a hidden class=anchor aria-hidden=true href=#编译的起点-gcmain>#</a></h2><p>Golang 编译器相关源码位于 <a href=https://github.com/golang/go/tree/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile><code>go/src/cmd/compile/</code></a>。</p><p>Go 编译处理的单位是 Package，得到的结果是 Object 文件。在一次编译过程开始时会读取 Package 中所有文件内容进行词法和语法分析。我们很容易就能找到编译器的入口文件 <code>main.go</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#75715e>// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/main.go#L45</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    <span style=color:#75715e>// disable timestamps for reproducible output</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>    <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>SetFlags</span>(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>SetPrefix</span>(<span style=color:#e6db74>&#34;compile: &#34;</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    <span style=color:#a6e22e>buildcfg</span>.<span style=color:#a6e22e>Check</span>()
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    <span style=color:#a6e22e>archInit</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>archInits</span>[<span style=color:#a6e22e>buildcfg</span>.<span style=color:#a6e22e>GOARCH</span>]
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintf</span>(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Stderr</span>, <span style=color:#e6db74>&#34;compile: unknown architecture %q\n&#34;</span>, <span style=color:#a6e22e>buildcfg</span>.<span style=color:#a6e22e>GOARCH</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>        <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>
</span></span><span style=display:flex;background-color:#3c3d38><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>    <span style=color:#a6e22e>gc</span>.<span style=color:#a6e22e>Main</span>(<span style=color:#a6e22e>archInit</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>    <span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>}
</span></span></code></pre></div><p><a href=https://github.com/golang/go/blob/78c3aba4704c86874c36e61224966e7e07706bc0/src/cmd/compile/internal/gc/main.go#L59><code>gc.Main()</code></a> 完成了整个编译流程，其内容是本文的重点；编译流程本身比较清晰，但内容很多，在本文中主要关心 <code>init()</code> 相关的处理。</p><p>为了方便理解，请先阅读编译器部分的 <a href=https://github.com/golang/go/blob/78c3aba4704c86874c36e61224966e7e07706bc0/src/cmd/compile/README.md>README.md</a>，了解编译器的基本流程和相关概念；下面也简单介绍一下编译器的流程，补充一些细节，便于理解为什么 Go 编译器现在是这样一个结构。</p><h2 id=编译流程>编译流程<a hidden class=anchor aria-hidden=true href=#编译流程>#</a></h2><h3 id=1-parsing>1. <a href=https://github.com/golang/go/blob/78c3aba4704c86874c36e61224966e7e07706bc0/src/cmd/compile/internal/syntax>Parsing</a><a hidden class=anchor aria-hidden=true href=#1-parsing>#</a></h3><p>词法和语法分析得到 AST（Abstract Syntax Tree，抽象语法树），每个 AST 等价于一个源文件。关于树的结构和节点的定义见 <a href=https://github.com/golang/go/blob/78c3aba4704c86874c36e61224966e7e07706bc0/src/cmd/compile/internal/syntax/nodes.go>internal/syntax/nodes.go</a>，Go 源码中的所有元素都能在这里找到对应的结构，极其基础和重要。</p><p>例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#75715e>// X[Index[0] : Index[1] : Index[2]]</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#a6e22e>SliceExpr</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    <span style=color:#a6e22e>X</span>     <span style=color:#a6e22e>Expr</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>    <span style=color:#a6e22e>Index</span> [<span style=color:#ae81ff>3</span>]<span style=color:#a6e22e>Expr</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    <span style=color:#75715e>// Full indicates whether this is a simple or full slice expression.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>    <span style=color:#75715e>// In a valid AST, this is equivalent to Index[2] != nil.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    <span style=color:#75715e>// TODO(mdempsky): This is only needed to report the &#34;3-index</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    <span style=color:#75715e>// slice of string&#34; error when Index[2] is missing.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    <span style=color:#a6e22e>Full</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    <span style=color:#a6e22e>expr</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>}
</span></span></code></pre></div><p>我们可以从中知道 slice[:] 操作实际上可以有三个参数，分别表示指针（新起始位置）、长度和容量。</p><p>同时也可以看到 Comments 相关结构仍在开发之中，后续可能会加入 AST 用于生成更加结构化的文档。</p><h3 id=2-type-checking>2. <a href=https://github.com/golang/go/blob/78c3aba4704c86874c36e61224966e7e07706bc0/src/cmd/compile/internal/types2>Type checking</a><a hidden class=anchor aria-hidden=true href=#2-type-checking>#</a></h3><p>类型检查，<code>types2</code> 是从 <code>go/types</code> 移植而来的，在这里需要结合发展历史来理解。</p><p>在一开始，Go 的编译器是使用 C 来实现的。到 Go 1.5 版本，实现了自举，其中编译过程中类型检查使用的是 Go 实现的传统检查算法，位于 <code>internal/gc/typecheck.go</code>；同时 Go 1.5 版本在标准库里面加入了 <code>go/types</code>，便于开发者开发 Go 代码分析工具。随着各种代码检查工具的涌现，<code>go/types</code> 发展迅猛，相比较而言，<code>internal/gc/typecheck.go</code> 涉及编译器过于底层，发展较慢。</p><p>直到 Go 1.17 开始开发，需要将泛型作为实验特性加入，此时编译器的类型检查已经无法满足要求，好在 <code>go/types</code> 已经十分成熟，借助其强大的类型推导能力，在编译器中实现了对泛型的处理；这也是 <code>internal/types2</code> 和 <code>go/types</code> 一开始相同的原因。后续对 <code>go/types</code> 问题的修复也应同步到 <code>types2</code>，这样才能保证编译器和代码分析工具的一致性，同时也相当于让更多人参与了编译器的改进；当然，编译器自身也有些特殊需求需要在 <code>types2</code> 中实现。由于现在有两种并行的实现，因此 <code>internal/gc/typecheck.go</code> 被抽取出来，成为了 <code>internal/typecheck</code> 包。</p><ul><li><p>在 Go 1.5 之前，编译器使用 C 实现，不存在 Go 实现的类型检查。</p></li><li><p>在 Go 1.5 - 1.16，编译器使用 Go 实现，类型检查使用 <code>gc/typecheck.go</code>，官方提供了 <code>go/types</code> 包。</p></li><li><p>在 Go 1.17 时泛型还只是可选项，因此编译器提供了参数 <code>-G</code> 来选择是否开启泛型，实际上，当 <code>G=0</code> 时编译器会使用旧的 <code>typecheck</code> 来进行类型检查；当 <code>G=3</code> 时使用 <code>types2</code> （<code>go/types</code>移植而来）进行类型检查以支持泛型。</p></li><li><p>在 Go 1.18 正式推出泛型以后，<code>-G</code> 参数仍然存在，只不过默认值改成了 <code>G=3</code>，也就是说，现在编译器默认使用 <code>types2</code> 进行类型检查。</p></li><li><p>在 Go 1.19 推出后，<code>-G</code> 参数被移除，编译器只能使用 <code>types2</code> 进行类型检查。</p></li></ul><p>例如 <a href=https://cs.opensource.google/go/go/+/8fd2875c3e9455df722dd3c930332591eebbb3c2>Commit:
8fd2875</a>：</p><p>修改 <code>src/go/types</code> 后，也同步修改了 <code>src/cmd/compile/internal/types2</code> 下的内容。</p><h3 id=3-ir-construction>3. <a href=https://github.com/golang/go/blob/78c3aba4704c86874c36e61224966e7e07706bc0/src/cmd/compile/internal/noder>IR construction(&ldquo;noding&rdquo;)</a><a hidden class=anchor aria-hidden=true href=#3-ir-construction>#</a></h3><p>IR（Intermediate Representation，中间表示）是一种介于 AST 和汇编代码之间的表示，是一种更加抽象的表示，能够更好地表示语义。这一步就是将 AST 转换为 IR，这个过程称作 <code>noding</code>。</p><ul><li><p>在 Go 1.17 之前，并没有 IR 的概念，或者说有，但是还不叫 IR。</p></li><li><p>在 Go 1.17，当 <code>G=0</code> 时，编译器可选择使用 <code>internal/typecheck</code> 进行类型检查，因此对应使用 <code>noder</code> 进行 <code>noding</code>；当 <code>G=3</code> 时，编译器使用 <code>types2</code> 进行类型检查，因此使用相应的新实现来进行 <code>noding</code>， 称之为 <code>noder2</code>。</p></li><li><p>在 Go 1.18，同样可以通过 <code>-G</code> 参数来选择使用 <code>internal/typecheck</code> 或者 <code>types2</code> 进行类型检查，因此 <code>noder</code> 和 <code>noder2</code> 仍然是并存的。</p></li><li><p>在 Go 1.19 之后，编译器只能使用 <code>types2</code> 进行类型检查，因此 <code>noder2</code> 也是唯一的 <code>noding</code> 实现。</p></li></ul><p>其实 IR 也是一种形式的 AST，被称为 <code>GC AST</code>（Go Compiler AST）。那么为什么要转换呢？主要原因是自 Go 1.5 实现自举时，参考旧 C 的实现来完成了 AST 上的类型检查等等后续操作；但是新的 Go 实现的词法语法分析得到的 AST 只是分别与源文件对应，还未处理 import 以及合并，并不完整；好在这个转换并不复杂。</p><p>旧的处理流程如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>// 旧处理流程 Go 1.5 - 1.16
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>[AST1,AST2,...] := Parse([file1,file2,...])
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>// 处理 import，合并 AST
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>IR := Noder([AST1,AST2,...])
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>// 类型检查
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>Typecheck(IR)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>MiddleEndOP(IR)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>SSA := SSAGen(IR)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>MACHINE_CODE := CodeGen(SSA)
</span></span></code></pre></div><p>在 Go 1.17 引入 <code>types2</code> 后，由于 <code>types2</code> 是作用于 AST 上的，因此新的处理流程变成了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>// 新处理流程 Go 1.17
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>[AST1,AST2,...] := Parse([file1,file2,...])
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>#if G=3
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    // 处理 import，类型检查，处理泛型
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>    TypeInfo := Types2([AST1,AST2,...])
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    IR := Noder2([AST1,AST2,...],TypeInfo)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>#elseif G=0
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    // 处理 import，合并 AST
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    IR := Noder([AST1,AST2,...])
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>#endif
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>// 之后完全一致
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>Typecheck(IR)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>MiddleEndOp(IR)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>SSA := SSAGen(IR)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>MACHINE_CODE := CodeGen(SSA)
</span></span></code></pre></div><p><code>noder2</code> 的实现位于 <code>internal/ir</code>。会发现当 <code>G=3</code> 时，虽然用了 <code>internal/types2</code> 来进行类型检查，但是后续在 IR 上还是跑了一遍 <code>internal/typecheck</code>，在这里有许多原因，主要是 <code>internal/typecheck</code> 会对 IR 进行一些修改调整，因此还需要保留，详情可以看这里的注释：<a href=https://github.com/golang/go/blob/4aa1efed4853ea067d665a952eee77c52faac774/src/cmd/compile/internal/noder/unified.go#L51>internal/noder/unified.go#L51</a>。</p><p>在 Go 1.18 又引入了 Unified IR（GOEXPERIMENT=unified 开启），于是乎三种流程并行存在：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>// 新处理流程 Go 1.18
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>[AST1,AST2,...] := Parse([file1,file2,...])
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>#if Unified
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    IR := Unified([AST1,AST2,...])
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>#else
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    #if G=3
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>        // 处理 import，类型检查，处理泛型
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>        TypeInfo := Types2([AST1,AST2,...])
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>        IR := Noder2([AST1,AST2,...],TypeInfo)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    #elseif G=0
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>        // 处理 import，合并 AST
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>        IR := Noder([AST1,AST2,...])
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>    #endif
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>    Typecheck(IR)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>#endif
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>MiddleEndOp(IR)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>SSA := SSAGen(IR)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>MACHINE_CODE := CodeGen(SSA)
</span></span></code></pre></div><p>在 Go 1.19 移除了 <code>G=0</code> 的流程：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>// 新处理流程 Go 1.19
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>[AST1,AST2,...] := Parse([file1,file2,...])
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>#if Unified
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    IR := Unified([AST1,AST2,...])
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>#else
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    // 处理 import，类型检查，处理泛型
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    TypeInfo := Types2([AST1,AST2,...])
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    IR := Noder2([AST1,AST2,...],TypeInfo)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    Typecheck(IR)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>#endif
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>MiddleEndOp(IR)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>SSA := SSAGen(IR)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>MACHINE_CODE := CodeGen(SSA)
</span></span></code></pre></div><p>在 Go 1.21 正式启用了 Unified IR，因此 <code>unified</code> 也就是唯一的 <code>noding</code> 实现了，确实实现了统一，欢迎来到 Go 1.21 ！（实际上需要处理的东西其实没有改变，只是整合在了 <code>Unified</code> 内，因此原来的包还依然存在）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span>// 新处理流程 Go 1.21
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span>[AST1,AST2,...] := Parse([file1,file2,...])
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>IR := Unified([AST1,AST2,...])
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>MiddleEndOp(IR)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>SSA := SSAGen(IR)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8</span><span>MACHINE_CODE := CodeGen(SSA)
</span></span></code></pre></div><p>下面是各种 <code>noder</code> 在不同版本的存在状态：</p><ul><li>Go 1.17 之前：noder</li><li>Go 1.17: noder, noder2</li><li>Go 1.18: noder, noder2, unified</li><li>Go 1.19: noder2, unified</li><li>Go 1.20: noder2, unified</li><li>Go 1.21: unified</li></ul><h3 id=4-middle-end>4. Middle end<a hidden class=anchor aria-hidden=true href=#4-middle-end>#</a></h3><ul><li><a href=https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/deadcode><code>internal/deadcode</code></a> (dead code elimination)</li><li><a href=https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/inline><code>internal/inline</code></a> (function call inlining)</li><li><a href=https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/devirtualize><code>internal/devirtualize</code></a> (devirtualization of known interface method calls)</li><li><a href=https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/escape><code>internal/escape</code></a> (escape analysis)</li></ul><h3 id=5-walkssa-gen-以及机器码生成>5. Walk，SSA Gen 以及机器码生成<a hidden class=anchor aria-hidden=true href=#5-walkssa-gen-以及机器码生成>#</a></h3><ul><li>Walk 遍历 IR，拆分复杂的语句以及将语法糖转换成基础的语句</li><li>SSA Gen 将 IR 转化为 Static Single Assignment (SSA) 形式，此时还与具体的机器无关</li><li>机器码生成会根据架构以及更多机器相关的信息，对 SSA 进行优化；同时进行栈帧分配，寄存器分配，指针存活分析等等，最终经过汇编器 <a href=https://github.com/golang/go/tree/d8117459c513e048eb72f11988d5416110dff359/src/cmd/internal/obj><code>cmd/internal/obj</code></a> 生成机器码。</li></ul><h2 id=流程中-init-相关的处理>流程中 init 相关的处理<a hidden class=anchor aria-hidden=true href=#流程中-init-相关的处理>#</a></h2><p>前面我们了解了 Go 编译器的流程，以及其发展变化的历史。接下来我们来看看其中 init 相关的具体处理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#75715e>// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/gc/main.go#L59</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#75715e>// Main parses flags and Go source files specified in the command-line</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span><span style=color:#75715e>// arguments, type-checks the parsed Go package, compiles functions to machine</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span><span style=color:#75715e>// code, and finally writes the compiled package definition to disk.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Main</span>(<span style=color:#a6e22e>archInit</span> <span style=color:#66d9ef>func</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>ssagen</span>.<span style=color:#a6e22e>ArchInfo</span>)) {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    <span style=color:#75715e>// Parse and typecheck input.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    <span style=color:#a6e22e>noder</span>.<span style=color:#a6e22e>LoadPackage</span>(<span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>Args</span>())
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    <span style=color:#75715e>// Create &#34;init&#34; function for package-scope variable initialization</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    <span style=color:#75715e>// statements, if any.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>    <span style=color:#75715e>//</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>    <span style=color:#75715e>// Note: This needs to happen early, before any optimizations. The</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>    <span style=color:#75715e>// Go spec defines a precise order than initialization should be</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>    <span style=color:#75715e>// carried out in, and even mundane optimizations like dead code</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>    <span style=color:#75715e>// removal can skew the results (e.g., #43444).</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>    <span style=color:#a6e22e>pkginit</span>.<span style=color:#a6e22e>MakeInit</span>()
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>    <span style=color:#75715e>// Build init task, if needed.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>initTask</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pkginit</span>.<span style=color:#a6e22e>Task</span>(); <span style=color:#a6e22e>initTask</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>        <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Export</span>(<span style=color:#a6e22e>initTask</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span>    <span style=color:#f92672>...</span>
</span></span></code></pre></div><p><code>gc.Main()</code> 流程中主要有以上三部分对 init 进行了处理，接下来我们分别看看这三部分。</p><h3 id=noderloadpackage>noder.LoadPackage()<a hidden class=anchor aria-hidden=true href=#noderloadpackage>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#75715e>// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/noder/noder.go#L27</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LoadPackage</span>(<span style=color:#a6e22e>filenames</span> []<span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>    <span style=color:#a6e22e>noders</span> <span style=color:#f92672>:=</span> make([]<span style=color:#f92672>*</span><span style=color:#a6e22e>noder</span>, len(<span style=color:#a6e22e>filenames</span>))
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>filename</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>filenames</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>            <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>            <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>                <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>                <span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#a6e22e>filename</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>                <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>                <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>file</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>syntax</span>.<span style=color:#a6e22e>Parse</span>(<span style=color:#a6e22e>fbase</span>, <span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>p</span>.<span style=color:#66d9ef>error</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>pragma</span>, <span style=color:#a6e22e>syntax</span>.<span style=color:#a6e22e>CheckBranches</span>) <span style=color:#75715e>// errors are tracked via p.error</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>            }()
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>        }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>    }()
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>    <span style=color:#a6e22e>unified</span>(<span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>noders</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>}
</span></span></code></pre></div><p>可以看到 <code>LoadPackage()</code> 会并行的对每个文件进行读取以及词法语法分析，构建 AST。并将得到的 AST 列表传递给 <code>unified()</code> 进行统一处理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#75715e>// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/noder/unified.go#L71</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>unified</span>(<span style=color:#a6e22e>m</span> <span style=color:#a6e22e>posMap</span>, <span style=color:#a6e22e>noders</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>noder</span>) {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>    <span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>writePkgStub</span>(<span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>noders</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>    <span style=color:#a6e22e>target</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Target</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>localPkgReader</span>.<span style=color:#a6e22e>newReader</span>(<span style=color:#a6e22e>pkgbits</span>.<span style=color:#a6e22e>RelocMeta</span>, <span style=color:#a6e22e>pkgbits</span>.<span style=color:#a6e22e>PrivateRootIdx</span>, <span style=color:#a6e22e>pkgbits</span>.<span style=color:#a6e22e>SyncPrivate</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>pkgInit</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>LocalPkg</span>, <span style=color:#a6e22e>target</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    <span style=color:#75715e>// 后面均为 `internal/typecheck` 的处理，与 init 无关</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    <span style=color:#75715e>// Type-check any top-level assignments. We ignore non-assignments</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>    <span style=color:#75715e>// here because other declarations are typechecked as they&#39;re</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>    <span style=color:#75715e>// constructed.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>ndecls</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>, len(<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>Decls</span>); <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>ndecls</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>        <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>Decls</span>[<span style=color:#a6e22e>i</span>]; <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>OAS</span>, <span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>OAS2</span>:
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>            <span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>Decls</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Stmt</span>(<span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>        }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>    <span style=color:#a6e22e>readBodies</span>(<span style=color:#a6e22e>target</span>, <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span>    <span style=color:#75715e>// Check that nothing snuck past typechecking.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>Decls</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Typecheck</span>() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span>            <span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>FatalfAt</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Pos</span>(), <span style=color:#e6db74>&#34;missed typecheck: %v&#34;</span>, <span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27</span><span>        }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29</span><span>        <span style=color:#75715e>// For functions, check that at least their first statement (if</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30</span><span>        <span style=color:#75715e>// any) was typechecked too.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31</span><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>fn</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>n</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>Func</span>); <span style=color:#a6e22e>ok</span> <span style=color:#f92672>&amp;&amp;</span> len(<span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>Body</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32</span><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>stmt</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>Body</span>[<span style=color:#ae81ff>0</span>]; <span style=color:#a6e22e>stmt</span>.<span style=color:#a6e22e>Typecheck</span>() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33</span><span>                <span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>FatalfAt</span>(<span style=color:#a6e22e>stmt</span>.<span style=color:#a6e22e>Pos</span>(), <span style=color:#e6db74>&#34;missed typecheck: %v&#34;</span>, <span style=color:#a6e22e>stmt</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34</span><span>            }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35</span><span>        }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38</span><span>}
</span></span></code></pre></div><p>其中 <code>writePkgStub()</code> 完成了类型检查。接下来的调用链有点长，在这里就不放源代码了，大致流程如下：</p><p>writePkgStub() -> <a href=https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/noder/irgen.go#L70>noder.checkFiles</a> -> <a href=https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/types2/api.go#L437>conf.Check()</a> -> <a href=https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/types2/check.go#L331>Checker.Files()</a> -> <a href=https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/types2/check.go#L335>check.checkFiles()</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#75715e>// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/types2/check.go#L335</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>check</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Checker</span>) <span style=color:#a6e22e>checkFiles</span>(<span style=color:#a6e22e>files</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>syntax</span>.<span style=color:#a6e22e>File</span>) (<span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>    print(<span style=color:#e6db74>&#34;== initFiles ==&#34;</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    <span style=color:#a6e22e>check</span>.<span style=color:#a6e22e>initFiles</span>(<span style=color:#a6e22e>files</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    print(<span style=color:#e6db74>&#34;== collectObjects ==&#34;</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    <span style=color:#a6e22e>check</span>.<span style=color:#a6e22e>collectObjects</span>()
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    print(<span style=color:#e6db74>&#34;== packageObjects ==&#34;</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    <span style=color:#a6e22e>check</span>.<span style=color:#a6e22e>packageObjects</span>()
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>    print(<span style=color:#e6db74>&#34;== processDelayed ==&#34;</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>    <span style=color:#a6e22e>check</span>.<span style=color:#a6e22e>processDelayed</span>(<span style=color:#ae81ff>0</span>) <span style=color:#75715e>// incl. all functions</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>    print(<span style=color:#e6db74>&#34;== cleanup ==&#34;</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>    <span style=color:#a6e22e>check</span>.<span style=color:#a6e22e>cleanup</span>()
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>    print(<span style=color:#e6db74>&#34;== initOrder ==&#34;</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>    <span style=color:#a6e22e>check</span>.<span style=color:#a6e22e>initOrder</span>()
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span>}
</span></span></code></pre></div><p><code>initFiles()</code> 用于检查文件开头的 package 语句所声明的名称是否符合要求，例如要跟当前 package 名一致，否则忽略这个文件（都经过词法语法分析了，白分析了，当然编译前就能检查出这些问题，一般不会进行到这里才发现）。</p><p><code>collectObjects()</code> 在此处对 import 的 Package 进行了加载，并将其置于相应的 Scope 中。可以看到这里仍然是按照文件顺序在进行处理，通过 <code>check.impMap</code> 来缓存已经加载的 Package；同时用 <code>pkgImports map[*Package]bool</code> 来记录本 Package 已经引用的 Package，避免其重复加入 <code>pkg.imports</code> 数组。</p><p>同时，还能从中看到一些特殊 import 的处理，例如 import . 和 import _ 以及别名。DotImport 会将 imported package 中的导出符号全部遍历导入到当前的 FileScope 中，而一般情况下是将 imported package 整个加入到当前的 FileScope 中，这样会有额外的层次结构。</p><blockquote><p>注意这里提到了 FileScope，我们知道在 Go 的同一个 Package 下，许多声明是不存在 FileScope 的，例如全局变量在一个文件中声明，另一个文件中可以直接使用；同名也会发生冲突，因为这些都在同一个 PackageScope 下。但是对于 import 操作来说，每个文件都有自己需要 import 的内容，因此需要一个 FileScope 来记录区分这些信息。</p></blockquote><p>Scope 结构组织好后，还需要检查 FileScope 跟 PackageScope 之间的冲突问题，这主要是 DotImport 导致的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#75715e>// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/types2/resolver.go#L472</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#75715e>// verify that objects in package and file scopes have different names</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>scope</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>fileScopes</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>obj</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>scope</span>.<span style=color:#a6e22e>elems</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>alt</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pkg</span>.<span style=color:#a6e22e>scope</span>.<span style=color:#a6e22e>Lookup</span>(<span style=color:#a6e22e>name</span>); <span style=color:#a6e22e>alt</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>            <span style=color:#f92672>...</span>
</span></span></code></pre></div><p><code>initOrder()</code> 是对一些有依赖关系的全局声明进行排序，并未涉及 init 的处理，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>    <span style=color:#75715e>// a depends on b and c, c depends on f</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    <span style=color:#a6e22e>a</span> = <span style=color:#a6e22e>b</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>c</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>    <span style=color:#a6e22e>b</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    <span style=color:#a6e22e>c</span> = <span style=color:#a6e22e>f</span>()
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    <span style=color:#75715e>// circular dependency</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    <span style=color:#a6e22e>d</span> = <span style=color:#a6e22e>e</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    <span style=color:#a6e22e>e</span> = <span style=color:#a6e22e>d</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>)
</span></span></code></pre></div><p>在 Go 中，能够被用于初始化表达式的对象被称为 Dependency 对象，有 Const, Var, Func 这三类。先构建对象依赖关系的有向图（Directed Graph），再以每个节点的依赖数目为权重构建最小堆（MinHeap）并以此堆作为最小优先级队列（PriorityQueue），因此队列头部的对象总是依赖其它对象最少的，所以该队列的遍历顺序就是初始化的顺序，是很常规的处理思路。要注意常量的初始化比较简单，在构建时就已经确定，在这里仍然加入是为了检测循环依赖。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#a6e22e>https</span>:<span style=color:#75715e>//github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/noder/unified.go#L209</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>writePkgStub</span>(<span style=color:#a6e22e>m</span> <span style=color:#a6e22e>posMap</span>, <span style=color:#a6e22e>noders</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>noder</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>    <span style=color:#75715e>// 类型检查</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>    <span style=color:#a6e22e>pkg</span>, <span style=color:#a6e22e>info</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>checkFiles</span>(<span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>noders</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>    <span style=color:#a6e22e>pw</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newPkgWriter</span>(<span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>pkg</span>, <span style=color:#a6e22e>info</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    <span style=color:#a6e22e>pw</span>.<span style=color:#a6e22e>collectDecls</span>(<span style=color:#a6e22e>noders</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>sb</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Builder</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    <span style=color:#a6e22e>pw</span>.<span style=color:#a6e22e>DumpTo</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sb</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>    <span style=color:#75715e>// At this point, we&#39;re done with types2. Make sure the package is</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>    <span style=color:#75715e>// garbage collected.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>    <span style=color:#a6e22e>freePackage</span>(<span style=color:#a6e22e>pkg</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sb</span>.<span style=color:#a6e22e>String</span>()
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>}
</span></span></code></pre></div><p>最后再回到开始，可见 <code>writePkgStub</code> 包含了 <code>internal/types2</code> 的类型检查；类型检查会涉及到外部包的导出类型，也就是说会处理 import 语句；同时，类型检查的过程中也生成了一份 <code>types2.Package</code> 以及 <code>types2.info</code>，其中 <code>types2.package</code> 包含 Scope 层次信息以及每个 Scope 中的 Object 信息；<code>types2.info</code> 包含了类型检查中生成的类型信息；最后通过 <code>pkgWriter</code> 将这两个信息整合序列化为字符串，也就是最终得到的 <code>data</code>。</p><p>实际上，这个 <code>data</code> 就是 Unified IR 的导出；接下来使用 <code>pkgReader</code> 将 <code>data</code> 重新构建为 IR，存储在 <code>typecheck.Target</code>。</p><blockquote><p>明明步骤紧接在一起，为什么要把 Unified IR 先 <code>export</code> 再 <code>import</code> 呢？
这样做主要是为了将 Unified IR 与后续部分完全解耦，可以看到只要有 <code>export data</code> 就能够完成后续的编译工作；同时通过实现不同的 pkgReader，便可以从 <code>export data</code> 中提取出不同的信息。例如编译器需要从中读取完整的 IR； <code>x/tools</code> 下的工具需要对代码进行静态分析，那么就可以实现一个 pkgReader 来提取自己需要的信息，而不必再自己实现一遍词法语法分析以及类型检查。</p></blockquote><p>在 <code>pkgReader</code> 构建 IR 的过程中，遇到函数类型的 Object 时，做了如下处理：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#75715e>// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/noder/reader.go#L750</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#66d9ef>case</span> <span style=color:#a6e22e>pkgbits</span>.<span style=color:#a6e22e>ObjFunc</span>:
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sym</span>.<span style=color:#a6e22e>Name</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;init&#34;</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>        <span style=color:#a6e22e>sym</span> = <span style=color:#a6e22e>Renameinit</span>()
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span><span style=color:#f92672>...</span>
</span></span></code></pre></div><p>可见 init 函数是多么特殊，它会被重命名，这样就不会与其他 init 函数冲突了。Renameinit() 的实现如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#75715e>// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/noder/noder.go#L419</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>renameinitgen</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Renameinit</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Sym</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>LookupNum</span>(<span style=color:#e6db74>&#34;init.&#34;</span>, <span style=color:#a6e22e>renameinitgen</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>    <span style=color:#a6e22e>renameinitgen</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7</span><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8</span><span>}
</span></span></code></pre></div><p>可见只是给了个编号，重命名成了一系列 init.0 init.1 init.2 等等的函数。</p><p>至此 <code>LoadPackage()</code> 的工作就完成了。</p><h3 id=pkginitmakeinit>pkginit.MakeInit()<a hidden class=anchor aria-hidden=true href=#pkginitmakeinit>#</a></h3><p>接下来终于来到了 pkginit 包的内容。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#75715e>// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/gc/main.go#L59</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#75715e>// Main parses flags and Go source files specified in the command-line</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span><span style=color:#75715e>// arguments, type-checks the parsed Go package, compiles functions to machine</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span><span style=color:#75715e>// code, and finally writes the compiled package definition to disk.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Main</span>(<span style=color:#a6e22e>archInit</span> <span style=color:#66d9ef>func</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>ssagen</span>.<span style=color:#a6e22e>ArchInfo</span>)) {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>    <span style=color:#75715e>// Parse and typecheck input.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    <span style=color:#a6e22e>noder</span>.<span style=color:#a6e22e>LoadPackage</span>(<span style=color:#a6e22e>flag</span>.<span style=color:#a6e22e>Args</span>())
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    <span style=color:#75715e>// Create &#34;init&#34; function for package-scope variable initialization</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    <span style=color:#75715e>// statements, if any.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>    <span style=color:#75715e>//</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>    <span style=color:#75715e>// Note: This needs to happen early, before any optimizations. The</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>    <span style=color:#75715e>// Go spec defines a precise order than initialization should be</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>    <span style=color:#75715e>// carried out in, and even mundane optimizations like dead code</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>    <span style=color:#75715e>// removal can skew the results (e.g., #43444).</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>    <span style=color:#a6e22e>pkginit</span>.<span style=color:#a6e22e>MakeInit</span>()
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>    <span style=color:#75715e>// Build init task, if needed.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>initTask</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pkginit</span>.<span style=color:#a6e22e>Task</span>(); <span style=color:#a6e22e>initTask</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>        <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Export</span>(<span style=color:#a6e22e>initTask</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span>    <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>从注释也可以知道，在词法分析、语法分析以及类型检查和构造 IR 树的过程中，均未涉及代码优化。以下是 MakeInit() 的内容，关键部分使用中文进行了更详细的注释，可以对照相关方法的源码进行阅读。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#75715e>// TODO(mdempsky): Move into noder, so that the types2-based frontends</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#75715e>// can use Info.InitOrder instead.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MakeInit</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>    <span style=color:#75715e>// Init 相关的处理只涉及全局声明（Package Level），依赖关系作为有向边来构建有向图，然后进行拓扑排序。</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>    <span style=color:#a6e22e>nf</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>initOrder</span>(<span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Target</span>.<span style=color:#a6e22e>Decls</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>    <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>nf</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    <span style=color:#75715e>// Make a function that contains all the initialization statements.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    <span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>Pos</span> = <span style=color:#a6e22e>nf</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>Pos</span>() <span style=color:#75715e>// prolog/epilog gets line number of first init stmt</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>    <span style=color:#75715e>// 查找 init 符号，如果 Package 的全局符号中没有则创建；不用担心 init 符号已经被用户的 init 函数使用，因为 IR 树在生成过程中遇到 init 会重命名为 init.0 init.1 这样的格式，前面提到 g.generate() 的时候也有说明。</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>    <span style=color:#a6e22e>initializers</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Lookup</span>(<span style=color:#e6db74>&#34;init&#34;</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>    <span style=color:#75715e>/* 用 init 符号声明一个新的函数，用于存放所有的初始化工作。具体实现是：此处在 IR 树中对应位置建立了新的 ONAME Node（ONAME 表示 var/func name），类型指定为 PFUNC，同时也将符号表中的 init 更新为 symFunc，表明这个符号是函数名；然后新建一个函数节点，将 ONAME Node 指向函数节点，最后将函数节点返回。
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>    <span style=color:#a6e22e>fn</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>DeclFunc</span>(<span style=color:#a6e22e>initializers</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>    <span style=color:#75715e>// 类型检查过程中生成了一个 InitTodoFunc，其作为全局初始化语句的临时上下文环境。现在将临时环境 InitTodoFunc 的内容转移到 fn。</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>dcl</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>InitTodoFunc</span>.<span style=color:#a6e22e>Dcl</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>        <span style=color:#a6e22e>dcl</span>.<span style=color:#a6e22e>Curfn</span> = <span style=color:#a6e22e>fn</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>    <span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>Dcl</span> = append(<span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>Dcl</span>, <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>InitTodoFunc</span>.<span style=color:#a6e22e>Dcl</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span>    <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>InitTodoFunc</span>.<span style=color:#a6e22e>Dcl</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span>    <span style=color:#75715e>// Suppress useless &#34;can inline&#34; diagnostics.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span>    <span style=color:#75715e>// Init functions are only called dynamically.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span>    <span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>SetInlinabilityChecked</span>(<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28</span><span>    <span style=color:#75715e>// 配置函数体。</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29</span><span>    <span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>Body</span> = <span style=color:#a6e22e>nf</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30</span><span>    <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>FinishFuncBody</span>()
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32</span><span>    <span style=color:#75715e>// 确定 fn 为函数节点</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33</span><span>    <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Func</span>(<span style=color:#a6e22e>fn</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34</span><span>    <span style=color:#75715e>// 在 fn 的内部上下文环境下检查函数体</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35</span><span>    <span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>WithFunc</span>(<span style=color:#a6e22e>fn</span>, <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36</span><span>        <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Stmts</span>(<span style=color:#a6e22e>nf</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37</span><span>    })
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38</span><span>    <span style=color:#75715e>// 把函数加入到 Package 的全局声明列表。</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39</span><span>    <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Target</span>.<span style=color:#a6e22e>Decls</span> = append(<span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Target</span>.<span style=color:#a6e22e>Decls</span>, <span style=color:#a6e22e>fn</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41</span><span>    <span style=color:#75715e>// Prepend to Inits, so it runs first, before any user-declared init</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42</span><span>    <span style=color:#75715e>// functions.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43</span><span>    <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Target</span>.<span style=color:#a6e22e>Inits</span> = append([]<span style=color:#f92672>*</span><span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>Func</span>{<span style=color:#a6e22e>fn</span>}, <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Target</span>.<span style=color:#a6e22e>Inits</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45</span><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>InitTodoFunc</span>.<span style=color:#a6e22e>Dcl</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46</span><span>        <span style=color:#75715e>// We only generate temps using InitTodoFunc if there</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47</span><span>        <span style=color:#75715e>// are package-scope initialization statements, so</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48</span><span>        <span style=color:#75715e>// something&#39;s weird if we get here.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49</span><span>        <span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;InitTodoFunc still has declarations&#34;</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51</span><span>    <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>InitTodoFunc</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52</span><span>}
</span></span></code></pre></div><p>旧版本中 MakeInit() 的工作是在 pkginit.Task() 中实现的，现在被抽取了出来，原因有以下几点。</p><ol><li><p>首先，MakeInit() 负责初始化函数的创建并插入 typecheck.Target.Inits，pkginit.Task() 得到了简化，毕竟这个初始化函数和其他用户定义的 init 实际上没有本质区别。</p></li><li><p>其次，敏锐的同学可能发现了，类型检查的过程中，已经进行了一次 initOrder()，但只检查了循环依赖的问题；这次又 initOrder() 显得有些冗余。因此将这一部分从 Task() 中拆分出来，希望以后能够放到类型检查的过程中，避免重复的排序操作。当前抽离成了单独的函数但是还未并入类型检查，处于中间状态，可见不久后将会并入类型检查，注释中的 TODO 就是在说这个问题。</p></li><li><p>最后，初始化函数如果在 Task() 中创建，则无法参与到类型检查结束到 Task() 开始这之间的优化过程，主要包括无效代码清理和内联优化。因此将其提前到类型检查结束后创建，这样就可以参与到优化过程中了。</p></li></ol><h3 id=pkginittask>pkginit.Task()<a hidden class=anchor aria-hidden=true href=#pkginittask>#</a></h3><p>最后，终于来到了 init 处理的终点， pkginit.Task()。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#75715e>// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/pkginit/init.go#L93</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#75715e>// Task makes and returns an initialization record for the package.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span><span style=color:#75715e>// See runtime/proc.go:initTask for its layout.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span><span style=color:#75715e>// The 3 tasks for initialization are:</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#75715e>//  1. Initialize all of the packages the current package depends on.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span><span style=color:#75715e>//  2. Initialize all the variables that have initializers.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#75715e>//  3. Run any init functions.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Task</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>Name</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>    <span style=color:#75715e>// Find imported packages with init tasks.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>    <span style=color:#75715e>// 这里可以看出 Package 最终的初始化任务被合并在了 .inittask 这个结构体中，因此对于引用的包才能这样进行查找，此处还检查了 .inittask 结构体是否合法。最终加入到 deps 数组。</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>pkg</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Target</span>.<span style=color:#a6e22e>Imports</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>        <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Resolve</span>(<span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>NewIdent</span>(<span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>Pos</span>, <span style=color:#a6e22e>pkg</span>.<span style=color:#a6e22e>Lookup</span>(<span style=color:#e6db74>&#34;.inittask&#34;</span>)))
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>ONONAME</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span>        }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Op</span>() <span style=color:#f92672>!=</span> <span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>ONAME</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>n</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>Name</span>).<span style=color:#a6e22e>Class</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>PEXTERN</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>            <span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;bad inittask: %v&#34;</span>, <span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>        }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span>        <span style=color:#a6e22e>deps</span> = append(<span style=color:#a6e22e>deps</span>, <span style=color:#a6e22e>n</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>Name</span>).<span style=color:#a6e22e>Linksym</span>())
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span>    <span style=color:#75715e>// 如果开启了 Address Sanitizer，那么需要在创建一个 init 函数加入 typecheck.Target.Inits，用于初始化 ASan 相关的全局变量。</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>Flag</span>.<span style=color:#a6e22e>ASan</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span>        <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span>        <span style=color:#75715e>// 可见这个 init 将会在最后执行</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27</span><span>        <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Target</span>.<span style=color:#a6e22e>Inits</span> = append(<span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Target</span>.<span style=color:#a6e22e>Inits</span>, <span style=color:#a6e22e>fnInit</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28</span><span>    }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">29</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">30</span><span>    <span style=color:#75715e>// Record user init functions.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">31</span><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>fn</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Target</span>.<span style=color:#a6e22e>Inits</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">32</span><span>        <span style=color:#75715e>// 只有处理 Package 全局变量的才叫 init，其它的都被重命名为了 init.0、init.1 等。</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">33</span><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>Sym</span>().<span style=color:#a6e22e>Name</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;init&#34;</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">34</span><span>            <span style=color:#75715e>// Synthetic init function for initialization of package-scope</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">35</span><span>            <span style=color:#75715e>// variables. We can use staticinit to optimize away static</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">36</span><span>            <span style=color:#75715e>// assignments.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">37</span><span>            <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>staticinit</span>.<span style=color:#a6e22e>Schedule</span>{
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">38</span><span>                <span style=color:#a6e22e>Plans</span>: make(<span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>Node</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>staticinit</span>.<span style=color:#a6e22e>Plan</span>),
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">39</span><span>                <span style=color:#a6e22e>Temps</span>: make(<span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>Node</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>Name</span>),
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">40</span><span>            }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">41</span><span>            <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>Body</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">42</span><span>                <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>StaticInit</span>(<span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">43</span><span>            }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">44</span><span>            <span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>Body</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Out</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">45</span><span>            <span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>WithFunc</span>(<span style=color:#a6e22e>fn</span>, <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">46</span><span>                <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Stmts</span>(<span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>Body</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">47</span><span>            })
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">48</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">49</span><span>            <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>Body</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">50</span><span>                <span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>Body</span> = []<span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>Node</span>{<span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>NewBlockStmt</span>(<span style=color:#a6e22e>src</span>.<span style=color:#a6e22e>NoXPos</span>, <span style=color:#66d9ef>nil</span>)}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">51</span><span>            }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">52</span><span>        }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">53</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">54</span><span>        <span style=color:#75715e>// Skip init functions with empty bodies.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">55</span><span>        <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>Body</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">56</span><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>stmt</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>Body</span>[<span style=color:#ae81ff>0</span>]; <span style=color:#a6e22e>stmt</span>.<span style=color:#a6e22e>Op</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>OBLOCK</span> <span style=color:#f92672>&amp;&amp;</span> len(<span style=color:#a6e22e>stmt</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>BlockStmt</span>).<span style=color:#a6e22e>List</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">57</span><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">58</span><span>            }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">59</span><span>        }
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">60</span><span>        <span style=color:#a6e22e>fns</span> = append(<span style=color:#a6e22e>fns</span>, <span style=color:#a6e22e>fn</span>.<span style=color:#a6e22e>Nname</span>.<span style=color:#a6e22e>Linksym</span>())
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">61</span><span>    }
</span></span></code></pre></div><p>最终 fns 数组保存了所有 init 函数；deps 数组保存了所有依赖的包的 .inittask 结构体。接下来合并构建自己 Package 的 .inittask。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span><span style=color:#75715e>// Make an .inittask structure.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span><span style=color:#a6e22e>sym</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Lookup</span>(<span style=color:#e6db74>&#34;.inittask&#34;</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span><span style=color:#a6e22e>task</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>NewName</span>(<span style=color:#a6e22e>sym</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span><span style=color:#75715e>// 显然这个 .inittask 不是 uint8 类型的，只是为了占位，因此这里设置了一个 fake type。</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span><span style=color:#a6e22e>task</span>.<span style=color:#a6e22e>SetType</span>(<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>Types</span>[<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>TUINT8</span>]) <span style=color:#75715e>// fake type</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span><span style=color:#a6e22e>task</span>.<span style=color:#a6e22e>Class</span> = <span style=color:#a6e22e>ir</span>.<span style=color:#a6e22e>PEXTERN</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span><span style=color:#a6e22e>sym</span>.<span style=color:#a6e22e>Def</span> = <span style=color:#a6e22e>task</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span><span style=color:#a6e22e>lsym</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>task</span>.<span style=color:#a6e22e>Linksym</span>()
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span><span style=color:#a6e22e>ot</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span><span style=color:#75715e>// lsym.P = [0]</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span><span style=color:#a6e22e>ot</span> = <span style=color:#a6e22e>objw</span>.<span style=color:#a6e22e>Uintptr</span>(<span style=color:#a6e22e>lsym</span>, <span style=color:#a6e22e>ot</span>, <span style=color:#ae81ff>0</span>) <span style=color:#75715e>// state: not initialized yet</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span><span style=color:#75715e>// lsym.P = [0, len(deps)]</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span><span style=color:#a6e22e>ot</span> = <span style=color:#a6e22e>objw</span>.<span style=color:#a6e22e>Uintptr</span>(<span style=color:#a6e22e>lsym</span>, <span style=color:#a6e22e>ot</span>, uint64(len(<span style=color:#a6e22e>deps</span>)))
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span><span style=color:#75715e>// lsym.P = [0, len(deps), len(fns)]</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span><span style=color:#a6e22e>ot</span> = <span style=color:#a6e22e>objw</span>.<span style=color:#a6e22e>Uintptr</span>(<span style=color:#a6e22e>lsym</span>, <span style=color:#a6e22e>ot</span>, uint64(len(<span style=color:#a6e22e>fns</span>)))
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span><span style=color:#75715e>// lsym.R = [newR(d)...]</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17</span><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>deps</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18</span><span>    <span style=color:#a6e22e>ot</span> = <span style=color:#a6e22e>objw</span>.<span style=color:#a6e22e>SymPtr</span>(<span style=color:#a6e22e>lsym</span>, <span style=color:#a6e22e>ot</span>, <span style=color:#a6e22e>d</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20</span><span><span style=color:#75715e>// lsym.R = [newR(d)..., newR(f)...]</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21</span><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>f</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>fns</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22</span><span>    <span style=color:#a6e22e>ot</span> = <span style=color:#a6e22e>objw</span>.<span style=color:#a6e22e>SymPtr</span>(<span style=color:#a6e22e>lsym</span>, <span style=color:#a6e22e>ot</span>, <span style=color:#a6e22e>f</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24</span><span><span style=color:#75715e>// An initTask has pointers, but none into the Go heap.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">25</span><span><span style=color:#75715e>// It&#39;s not quite read only, the state field must be modifiable.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">26</span><span><span style=color:#75715e>// 此处说明这个 .inittask 符号是全局的，决定了最后在 object 文件中的位置区域。</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">27</span><span><span style=color:#a6e22e>objw</span>.<span style=color:#a6e22e>Global</span>(<span style=color:#a6e22e>lsym</span>, int32(<span style=color:#a6e22e>ot</span>), <span style=color:#a6e22e>obj</span>.<span style=color:#a6e22e>NOPTR</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">28</span><span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>task</span>
</span></span></code></pre></div><p>在最后将其设置为导出的（Export），因为其符号名并非大写字母开头，但是要被其他包使用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#75715e>// Build init task, if needed.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>initTask</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pkginit</span>.<span style=color:#a6e22e>Task</span>(); <span style=color:#a6e22e>initTask</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>    <span style=color:#a6e22e>typecheck</span>.<span style=color:#a6e22e>Export</span>(<span style=color:#a6e22e>initTask</span>)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>}
</span></span></code></pre></div><p>至此，Package 单元对于 init 的处理就结束了，最后 Package 被编译为带有 .inittask 表的 object 文件，这个表中包含了所有的 init.x 函数和依赖的包的 .inittask 结构体指针，要注意这里只知道符号之间的关系，其他包里 init 函数的具体实现是不知道的，需要在链接阶段处理。</p><p>链接时，在拥有了所有的 .inittask 包含的具体函数相关信息后，链接器会将其按照依赖关系进行排序，生成一个具体的 mainInittasks 列表供 runtime 使用。此处不再展开这一部分，有兴趣的同学可以自行阅读链接器 inittask 部分的源码：<code>src/cmd/link/internal/ld/inittask.go</code>，最终 SymbolName 为 <code>go:main.inittasks</code>。</p><p>最终链接生成可执行文件时，inittasks 的地址会给到 <code>src/runtime/proc.go</code> 的 runtime_inittasks 数组变量，然后在<code>runtime.main</code> 函数中被使用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#75715e>// https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/runtime/proc.go#L144</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4</span><span>    <span style=color:#a6e22e>doInit</span>(<span style=color:#a6e22e>runtime_inittasks</span>) <span style=color:#75715e>// Must be before defer.</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5</span><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6</span><span>}
</span></span></code></pre></div><p>最后回看一开始发现的现象：</p><p>[现象]：<code>a/b.go</code> 和 <code>a/c.go</code> 的 init() 函数的执行顺序是按照文件名的字母顺序来的，将 <code>a/b.go</code> 改名后，其文件名顺序排在了 <code>a/c.go</code> 之后，最终 init() 执行也排在了之后。</p><p>根源在于编译器在读取源文件时是按照文件系统文件名顺序读入，在处理时也是依文件次序处理的，也就是编译器遇到 init 和 import 的顺序都是由文件名顺序决定的。</p><ol><li><p>虽然有 <code>initOrder()</code> 的存在，但是它不会影响用户定义的 <code>init()</code> 的顺序</p></li><li><p><code>initOrder()</code> 会处理 import 的依赖关系，因此最终各个 Package 的 init 顺序时根据依赖关系决定的。</p></li></ol><p>例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#75715e>// a1.go</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;b&#34;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#75715e>// a2.go</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;c&#34;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#75715e>// b.go</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2</span><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;c&#34;</span>
</span></span></code></pre></div><p>那么不管 a1.go 和 a2.go 的文件名顺序如何，package c 都会先于 package b 初始化，因为 b 依赖 c。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xinrea.cn/tags/golang/>Golang</a></li><li><a href=https://xinrea.cn/tags/compiler/>Compiler</a></li><li><a href=https://xinrea.cn/tags/init-function/>Init Function</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://xinrea.cn/>杏仁儿的博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>