<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on 杏仁儿</title><link>https://xinrea.github.io/posts/</link><description>Recent content in Posts on 杏仁儿</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 27 Mar 2022 17:35:21 +0000</lastBuildDate><atom:link href="https://xinrea.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Qt OpenglWindow 异形窗口的实现</title><link>https://xinrea.github.io/posts/qt-opengl-semi-window/</link><pubDate>Sun, 27 Mar 2022 17:35:21 +0000</pubDate><guid>https://xinrea.github.io/posts/qt-opengl-semi-window/</guid><description>在学习熟悉 CubismSDK 的时候，曾给轴伊Joi制作过一个简单的 Live2D 桌面宠物；由于是在官方样例的基础上修改了，因此是通过 glew + glfw 来实现的。由于桌面宠物的特殊性，需要尽可能减少对桌面操作的影响，于是需要实现异形窗口。这个异形窗口与一般的需求还不太一样，通常的异形窗口是静态的，仅以一张图片作为底图，有很多种方法可以实现，其中一种便是是用蒙版（mask）来实现。
但对于动态渲染，用 OpenGL 实现的桌面宠物来说，读取当前 Buffer 生成 mask 是效率极低的。好在 Windows 下提供了 SetLayeredWindowAttributes(hwnd,RGB(0, 0, 0), 255, LWA_COLORKEY) 这一方法，直接进行键值抠图即可。但问题是其精度极低，渲染出的模型边缘会出现很明显的底色锯齿边缘。
在 glfw 中，通过 glfwWindowHint(GLFW_TRANSPARENT_FRAMEBUFFER, GLFW_TRUE) 可实现窗口 Buffer 新增 Alpha 通道；配合 LWA_COLORKEY 即可实现无锯齿边缘的 OpenGL 渲染的即时异形窗口。
然而最近在使用 Qt 对其重构的过程中，又遇到了异形窗口的这一问题。Qt 提供了两种使用 OpenGL 的方式，QOpenGLWindow 与 QOpenGLWidget；这两种方式在使用上几乎没有差异，可以很方便的互相转换。但在实现异形窗口的过程中遇到了问题。
通过实践发现，QOpenGLWidget 通过设置 Qt::WA_TranslucentBackground 可以很简单的实现透明背景；但 LWA_COLORKEY 只对 WS_EX_LAYERED 样式的窗口生效；经过测试，QOpenGLWidget 单独作为窗口时，无法设置 WS_EX_LAYERED 样式，因此无法实现异形窗口。
QOpenGLWindow 可以直接设置 WS_EX_LAYERED 样式，但无法设置透明背景（可使用 setFormat 添加 alpha 通道属性，但配合 LWA_COLORKEY 会显示异常）；因此需要自行实现 GLFW_TRANSPARENT_FRAMEBUFFER 的功能。
通过阅读 glfw 源码，该设置相关的代码如下所示：</description></item><item><title>一个 gRPC 的连接问题</title><link>https://xinrea.github.io/posts/about-grpc-connection/</link><pubDate>Tue, 22 Mar 2022 14:45:52 +0000</pubDate><guid>https://xinrea.github.io/posts/about-grpc-connection/</guid><description>最近在开发的项目用到了 gRPC，并且要求使用证书进行双向认证。于是便生成了一个 CA 证书，并以此签名生成了服务端和客户端所需的各种证书，且在周五进行客户端服务端连接测试时一切正常。周末两天过去了，周一再进行测试时，连接出现了如下错误:
transport: authentication handshake failed: EOF
一开始还以为是证书验证出了问题，对相关证书以及涉及到的代码进行了回退，然后进行测试，仍然出现该问题。后续经过排查，排除了证书出错的这一原因，最后莫名在重启电脑后恢复了正常。后来发现是电脑上安装的梯子导致了这一问题。该问题的产生涉及到的前置原因如下：
由于办公网络环境较差，于是临时安装梯子，搭配手机热点进行开发工作 由于需要使用证书双向认证，在证书 SANs 中添加了域名 *.sample.com 由于证书的使用需验证域名，因此本地测试时，修改 /etc/hosts 文件将相关域名解析到了本地地址 127.0.0.1 测试用的域名匹配了代理规则 由于使用域名测试连接，匹配了代理的规则，导致本地测试的连接无法建立，出现了上述的问题。由于客户端和服务端均在本地进行测试，因此一开始并未考虑连接问题，但最终发现问题是经梯子代理导致无法建立连接。</description></item><item><title>关于</title><link>https://xinrea.github.io/posts/about/</link><pubDate>Tue, 22 Mar 2022 01:46:46 +0800</pubDate><guid>https://xinrea.github.io/posts/about/</guid><description>是时候重新开始写写博客了，工作了这么长时间，又自己写了很多小的项目，还是有许多东西可以总结的，希望能养成一个好的习惯。或许以后也能以此为线索，回忆起自己曾经的生活。</description></item></channel></rss>