[{"content":" 本文中引用的源码均标注了 Golang 源码仓库链接，branch 为 release-branch.go1.21（本文在编写时 Go 1.21 还未正式发布，正式版可能会有少量变化）。\ninit() 在不规范使用情况下产生的现象 在同一个 go 文件里，初始相关操作的执行顺序是 const -\u0026gt; var -\u0026gt; init()。显然，如果同一个文件里有多个 init()，那么将按照声明顺序来执行。\n如果 Package 的 init() 分布在不同的文件里，将会按照什么顺序来执行呢？\n有如下场景：\n1 2 3 main.go a/b.go a/c.go 1 2 3 4 5 6 7 8 // main.go package main import \u0026#34;go-init/a\u0026#34; func main() { a.A() } 1 2 3 4 5 6 7 8 9 10 11 // a/b.go package a func init() { println(\u0026#34;b init\u0026#34;) } func A() int { println(\u0026#34;A\u0026#34;) return 0 } 1 2 3 4 5 6 // a/c.go package a func init() { println(\u0026#34;c init\u0026#34;) } 执行 go run main.go，得到输出：\n1 2 3 b init c init A 接下来将 a/b.go 改名为 a/d.go，再次执行 go run main.go，输出：\n1 2 3 c init b init A 可以看到有 [现象]：a/b.go 和 a/c.go 的 init() 函数的执行顺序是按照文件名的字母顺序来的，将 a/b.go 改名后，其文件名顺序排在了 a/c.go 之后，最终 init() 执行也排在了之后。\n还有更多复杂的情况，例如：\n如果 import 的包之间存在依赖关系，那么这些包的 init() 的执行顺序是怎样的？ 如果 Package 的 init() 分布在不同的文件里，而且这些文件里有交叉依赖的 var 全局变量，那么 init() 和这些全局变量初始化的执行顺序又是怎样的？ 实际上，要真正弄清楚这些，需要深入 Go 编译器，从根源弄清原理。init() 的处理是 Go 编译过程中的重要一环。\n编译的起点 gc.Main() Golang 编译器相关源码位于 go/src/cmd/compile/。\nGo 编译处理的单位是 Package，得到的结果是 Object 文件。在一次编译过程开始时会读取 Package 中所有文件内容进行词法和语法分析。我们很容易就能找到编译器的入口文件 main.go：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/main.go#L45 func main() { // disable timestamps for reproducible output log.SetFlags(0) log.SetPrefix(\u0026#34;compile: \u0026#34;) buildcfg.Check() archInit, ok := archInits[buildcfg.GOARCH] if !ok { fmt.Fprintf(os.Stderr, \u0026#34;compile: unknown architecture %q\\n\u0026#34;, buildcfg.GOARCH) os.Exit(2) } gc.Main(archInit) base.Exit(0) } gc.Main() 完成了整个编译流程，其内容是本文的重点；编译流程本身比较清晰，但内容很多，在本文中主要关心 init() 相关的处理。\n为了方便理解，请先阅读编译器部分的 README.md，了解编译器的基本流程和相关概念；下面也简单介绍一下编译器的流程，补充一些细节，便于理解为什么 Go 编译器现在是这样一个结构。\n编译流程 1. Parsing 词法和语法分析得到 AST（Abstract Syntax Tree，抽象语法树），每个 AST 等价于一个源文件。关于树的结构和节点的定义见 internal/syntax/nodes.go，Go 源码中的所有元素都能在这里找到对应的结构，极其基础和重要。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 // X[Index[0] : Index[1] : Index[2]] SliceExpr struct { X Expr Index [3]Expr // Full indicates whether this is a simple or full slice expression. // In a valid AST, this is equivalent to Index[2] != nil. // TODO(mdempsky): This is only needed to report the \u0026#34;3-index // slice of string\u0026#34; error when Index[2] is missing. Full bool expr } 我们可以从中知道 slice[:] 操作实际上可以有三个参数，分别表示指针（新起始位置）、长度和容量。\n同时也可以看到 Comments 相关结构仍在开发之中，后续可能会加入 AST 用于生成更加结构化的文档。\n2. Type checking 类型检查，types2 是从 go/types 移植而来的，在这里需要结合发展历史来理解。\n在一开始，Go 的编译器是使用 C 来实现的。到 Go 1.5 版本，实现了自举，其中编译过程中类型检查使用的是 Go 实现的传统检查算法，位于 internal/gc/typecheck.go；同时 Go 1.5 版本在标准库里面加入了 go/types，便于开发者开发 Go 代码分析工具。随着各种代码检查工具的涌现，go/types 发展迅猛，相比较而言，internal/gc/typecheck.go 涉及编译器过于底层，发展较慢。\n直到 Go 1.17 开始开发，需要将泛型作为实验特性加入，此时编译器的类型检查已经无法满足要求，好在 go/types 已经十分成熟，借助其强大的类型推导能力，在编译器中实现了对泛型的处理；这也是 internal/types2 和 go/types 一开始相同的原因。后续对 go/types 问题的修复也应同步到 types2，这样才能保证编译器和代码分析工具的一致性，同时也相当于让更多人参与了编译器的改进；当然，编译器自身也有些特殊需求需要在 types2 中实现。由于现在有两种并行的实现，因此 internal/gc/typecheck.go 被抽取出来，成为了 internal/typecheck 包。\n在 Go 1.5 之前，编译器使用 C 实现，不存在 Go 实现的类型检查。\n在 Go 1.5 - 1.16，编译器使用 Go 实现，类型检查使用 gc/typecheck.go，官方提供了 go/types 包。\n在 Go 1.17 时泛型还只是可选项，因此编译器提供了参数 -G 来选择是否开启泛型，实际上，当 G=0 时编译器会使用旧的 typecheck 来进行类型检查；当 G=3 时使用 types2 （go/types移植而来）进行类型检查以支持泛型。\n在 Go 1.18 正式推出泛型以后，-G 参数仍然存在，只不过默认值改成了 G=3，也就是说，现在编译器默认使用 types2 进行类型检查。\n在 Go 1.19 推出后，-G 参数被移除，编译器只能使用 types2 进行类型检查。\n例如 Commit: 8fd2875：\n修改 src/go/types 后，也同步修改了 src/cmd/compile/internal/types2 下的内容。\n3. IR construction(\u0026ldquo;noding\u0026rdquo;) IR（Intermediate Representation，中间表示）是一种介于 AST 和汇编代码之间的表示，是一种更加抽象的表示，能够更好地表示语义。这一步就是将 AST 转换为 IR，这个过程称作 noding。\n在 Go 1.17 之前，并没有 IR 的概念，或者说有，但是还不叫 IR。\n在 Go 1.17，当 G=0 时，编译器可选择使用 internal/typecheck 进行类型检查，因此对应使用 noder 进行 noding；当 G=3 时，编译器使用 types2 进行类型检查，因此使用相应的新实现来进行 noding， 称之为 noder2。\n在 Go 1.18，同样可以通过 -G 参数来选择使用 internal/typecheck 或者 types2 进行类型检查，因此 noder 和 noder2 仍然是并存的。\n在 Go 1.19 之后，编译器只能使用 types2 进行类型检查，因此 noder2 也是唯一的 noding 实现。\n其实 IR 也是一种形式的 AST，被称为 GC AST（Go Compiler AST）。那么为什么要转换呢？主要原因是自 Go 1.5 实现自举时，参考旧 C 的实现来完成了 AST 上的类型检查等等后续操作；但是新的 Go 实现的词法语法分析得到的 AST 只是分别与源文件对应，还未处理 import 以及合并，并不完整；好在这个转换并不复杂。\n旧的处理流程如下所示：\n1 2 3 4 5 6 7 8 9 10 11 // 旧处理流程 Go 1.5 - 1.16 [AST1,AST2,...] := Parse([file1,file2,...]) // 处理 import，合并 AST IR := Noder([AST1,AST2,...]) // 类型检查 Typecheck(IR) MiddleEndOP(IR) SSA := SSAGen(IR) MACHINE_CODE := CodeGen(SSA) 在 Go 1.17 引入 types2 后，由于 types2 是作用于 AST 上的，因此新的处理流程变成了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 新处理流程 Go 1.17 [AST1,AST2,...] := Parse([file1,file2,...]) #if G=3 // 处理 import，类型检查，处理泛型 TypeInfo := Types2([AST1,AST2,...]) IR := Noder2([AST1,AST2,...],TypeInfo) #elseif G=0 // 处理 import，合并 AST IR := Noder([AST1,AST2,...]) #endif // 之后完全一致 Typecheck(IR) MiddleEndOp(IR) SSA := SSAGen(IR) MACHINE_CODE := CodeGen(SSA) noder2 的实现位于 internal/ir。会发现当 G=3 时，虽然用了 internal/types2 来进行类型检查，但是后续在 IR 上还是跑了一遍 internal/typecheck，在这里有许多原因，主要是 internal/typecheck 会对 IR 进行一些修改调整，因此还需要保留，详情可以看这里的注释：internal/noder/unified.go#L51。\n在 Go 1.18 又引入了 Unified IR（GOEXPERIMENT=unified 开启），于是乎三种流程并行存在：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 新处理流程 Go 1.18 [AST1,AST2,...] := Parse([file1,file2,...]) #if Unified IR := Unified([AST1,AST2,...]) #else #if G=3 // 处理 import，类型检查，处理泛型 TypeInfo := Types2([AST1,AST2,...]) IR := Noder2([AST1,AST2,...],TypeInfo) #elseif G=0 // 处理 import，合并 AST IR := Noder([AST1,AST2,...]) #endif Typecheck(IR) #endif MiddleEndOp(IR) SSA := SSAGen(IR) MACHINE_CODE := CodeGen(SSA) 在 Go 1.19 移除了 G=0 的流程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 新处理流程 Go 1.19 [AST1,AST2,...] := Parse([file1,file2,...]) #if Unified IR := Unified([AST1,AST2,...]) #else // 处理 import，类型检查，处理泛型 TypeInfo := Types2([AST1,AST2,...]) IR := Noder2([AST1,AST2,...],TypeInfo) Typecheck(IR) #endif MiddleEndOp(IR) SSA := SSAGen(IR) MACHINE_CODE := CodeGen(SSA) 在 Go 1.21 正式启用了 Unified IR，因此 unified 也就是唯一的 noding 实现了，确实实现了统一，欢迎来到 Go 1.21 ！（实际上需要处理的东西其实没有改变，只是整合在了 Unified 内，因此原来的包还依然存在）\n1 2 3 4 5 6 7 8 // 新处理流程 Go 1.21 [AST1,AST2,...] := Parse([file1,file2,...]) IR := Unified([AST1,AST2,...]) MiddleEndOp(IR) SSA := SSAGen(IR) MACHINE_CODE := CodeGen(SSA) 下面是各种 noder 在不同版本的存在状态：\nGo 1.17 之前：noder Go 1.17: noder, noder2 Go 1.18: noder, noder2, unified Go 1.19: noder2, unified Go 1.20: noder2, unified Go 1.21: unified 4. Middle end internal/deadcode (dead code elimination) internal/inline (function call inlining) internal/devirtualize (devirtualization of known interface method calls) internal/escape (escape analysis) 5. Walk，SSA Gen 以及机器码生成 Walk 遍历 IR，拆分复杂的语句以及将语法糖转换成基础的语句 SSA Gen 将 IR 转化为 Static Single Assignment (SSA) 形式，此时还与具体的机器无关 机器码生成会根据架构以及更多机器相关的信息，对 SSA 进行优化；同时进行栈帧分配，寄存器分配，指针存活分析等等，最终经过汇编器 cmd/internal/obj 生成机器码。 流程中 init 相关的处理 前面我们了解了 Go 编译器的流程，以及其发展变化的历史。接下来我们来看看其中 init 相关的具体处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/gc/main.go#L59 // Main parses flags and Go source files specified in the command-line // arguments, type-checks the parsed Go package, compiles functions to machine // code, and finally writes the compiled package definition to disk. func Main(archInit func(*ssagen.ArchInfo)) { ... // Parse and typecheck input. noder.LoadPackage(flag.Args()) ... // Create \u0026#34;init\u0026#34; function for package-scope variable initialization // statements, if any. // // Note: This needs to happen early, before any optimizations. The // Go spec defines a precise order than initialization should be // carried out in, and even mundane optimizations like dead code // removal can skew the results (e.g., #43444). pkginit.MakeInit() ... // Build init task, if needed. if initTask := pkginit.Task(); initTask != nil { typecheck.Export(initTask) } ... gc.Main() 流程中主要有以上三部分对 init 进行了处理，接下来我们分别看看这三部分。\nnoder.LoadPackage() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/noder/noder.go#L27 func LoadPackage(filenames []string) { ... noders := make([]*noder, len(filenames)) ... go func() { for i, filename := range filenames { ... go func() { ... f, err := os.Open(filename) ... p.file, _ = syntax.Parse(fbase, f, p.error, p.pragma, syntax.CheckBranches) // errors are tracked via p.error }() } }() ... unified(m, noders) } 可以看到 LoadPackage() 会并行的对每个文件进行读取以及词法语法分析，构建 AST。并将得到的 AST 列表传递给 unified() 进行统一处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/noder/unified.go#L71 func unified(m posMap, noders []*noder) { ... data := writePkgStub(m, noders) ... target := typecheck.Target r := localPkgReader.newReader(pkgbits.RelocMeta, pkgbits.PrivateRootIdx, pkgbits.SyncPrivate) r.pkgInit(types.LocalPkg, target) // 后面均为 `internal/typecheck` 的处理，与 init 无关 // Type-check any top-level assignments. We ignore non-assignments // here because other declarations are typechecked as they\u0026#39;re // constructed. for i, ndecls := 0, len(target.Decls); i \u0026lt; ndecls; i++ { switch n := target.Decls[i]; n.Op() { case ir.OAS, ir.OAS2: target.Decls[i] = typecheck.Stmt(n) } } readBodies(target, false) // Check that nothing snuck past typechecking. for _, n := range target.Decls { if n.Typecheck() == 0 { base.FatalfAt(n.Pos(), \u0026#34;missed typecheck: %v\u0026#34;, n) } // For functions, check that at least their first statement (if // any) was typechecked too. if fn, ok := n.(*ir.Func); ok \u0026amp;\u0026amp; len(fn.Body) != 0 { if stmt := fn.Body[0]; stmt.Typecheck() == 0 { base.FatalfAt(stmt.Pos(), \u0026#34;missed typecheck: %v\u0026#34;, stmt) } } } ... } 其中 writePkgStub() 完成了类型检查。接下来的调用链有点长，在这里就不放源代码了，大致流程如下：\nwritePkgStub() -\u0026gt; noder.checkFiles -\u0026gt; conf.Check() -\u0026gt; Checker.Files() -\u0026gt; check.checkFiles()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/types2/check.go#L335 func (check *Checker) checkFiles(files []*syntax.File) (err error) { ... print(\u0026#34;== initFiles ==\u0026#34;) check.initFiles(files) print(\u0026#34;== collectObjects ==\u0026#34;) check.collectObjects() print(\u0026#34;== packageObjects ==\u0026#34;) check.packageObjects() print(\u0026#34;== processDelayed ==\u0026#34;) check.processDelayed(0) // incl. all functions print(\u0026#34;== cleanup ==\u0026#34;) check.cleanup() print(\u0026#34;== initOrder ==\u0026#34;) check.initOrder() ... } initFiles() 用于检查文件开头的 package 语句所声明的名称是否符合要求，例如要跟当前 package 名一致，否则忽略这个文件（都经过词法语法分析了，白分析了，当然编译前就能检查出这些问题，一般不会进行到这里才发现）。\ncollectObjects() 在此处对 import 的 Package 进行了加载，并将其置于相应的 Scope 中。可以看到这里仍然是按照文件顺序在进行处理，通过 check.impMap 来缓存已经加载的 Package；同时用 pkgImports map[*Package]bool 来记录本 Package 已经引用的 Package，避免其重复加入 pkg.imports 数组。\n同时，还能从中看到一些特殊 import 的处理，例如 import . 和 import _ 以及别名。DotImport 会将 imported package 中的导出符号全部遍历导入到当前的 FileScope 中，而一般情况下是将 imported package 整个加入到当前的 FileScope 中，这样会有额外的层次结构。\n注意这里提到了 FileScope，我们知道在 Go 的同一个 Package 下，许多声明是不存在 FileScope 的，例如全局变量在一个文件中声明，另一个文件中可以直接使用；同名也会发生冲突，因为这些都在同一个 PackageScope 下。但是对于 import 操作来说，每个文件都有自己需要 import 的内容，因此需要一个 FileScope 来记录区分这些信息。\nScope 结构组织好后，还需要检查 FileScope 跟 PackageScope 之间的冲突问题，这主要是 DotImport 导致的。\n1 2 3 4 5 6 // https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/types2/resolver.go#L472 // verify that objects in package and file scopes have different names for _, scope := range fileScopes { for name, obj := range scope.elems { if alt := pkg.scope.Lookup(name); alt != nil { ... initOrder() 是对一些有依赖关系的全局声明进行排序，并未涉及 init 的处理，例如：\n1 2 3 4 5 6 7 8 9 10 var ( // a depends on b and c, c depends on f a = b + c b = 1 c = f() // circular dependency d = e e = d ) 在 Go 中，能够被用于初始化表达式的对象被称为 Dependency 对象，有 Const, Var, Func 这三类。先构建对象依赖关系的有向图（Directed Graph），再以每个节点的依赖数目为权重构建最小堆（MinHeap）并以此堆作为最小优先级队列（PriorityQueue），因此队列头部的对象总是依赖其它对象最少的，所以该队列的遍历顺序就是初始化的顺序，是很常规的处理思路。要注意常量的初始化比较简单，在构建时就已经确定，在这里仍然加入是为了检测循环依赖。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/noder/unified.go#L209 func writePkgStub(m posMap, noders []*noder) string { // 类型检查 pkg, info := checkFiles(m, noders) pw := newPkgWriter(m, pkg, info) pw.collectDecls(noders) ... var sb strings.Builder pw.DumpTo(\u0026amp;sb) // At this point, we\u0026#39;re done with types2. Make sure the package is // garbage collected. freePackage(pkg) return sb.String() } 最后再回到开始，可见 writePkgStub 包含了 internal/types2 的类型检查；类型检查会涉及到外部包的导出类型，也就是说会处理 import 语句；同时，类型检查的过程中也生成了一份 types2.Package 以及 types2.info，其中 types2.package 包含 Scope 层次信息以及每个 Scope 中的 Object 信息；types2.info 包含了类型检查中生成的类型信息；最后通过 pkgWriter 将这两个信息整合序列化为字符串，也就是最终得到的 data。\n实际上，这个 data 就是 Unified IR 的导出；接下来使用 pkgReader 将 data 重新构建为 IR，存储在 typecheck.Target。\n明明步骤紧接在一起，为什么要把 Unified IR 先 export 再 import 呢？ 这样做主要是为了将 Unified IR 与后续部分完全解耦，可以看到只要有 export data 就能够完成后续的编译工作；同时通过实现不同的 pkgReader，便可以从 export data 中提取出不同的信息。例如编译器需要从中读取完整的 IR； x/tools 下的工具需要对代码进行静态分析，那么就可以实现一个 pkgReader 来提取自己需要的信息，而不必再自己实现一遍词法语法分析以及类型检查。\n在 pkgReader 构建 IR 的过程中，遇到函数类型的 Object 时，做了如下处理：\n1 2 3 4 5 6 // https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/noder/reader.go#L750 case pkgbits.ObjFunc: if sym.Name == \u0026#34;init\u0026#34; { sym = Renameinit() } ... 可见 init 函数是多么特殊，它会被重命名，这样就不会与其他 init 函数冲突了。Renameinit() 的实现如下：\n1 2 3 4 5 6 7 8 // https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/noder/noder.go#L419 var renameinitgen int func Renameinit() *types.Sym { s := typecheck.LookupNum(\u0026#34;init.\u0026#34;, renameinitgen) renameinitgen++ return s } 可见只是给了个编号，重命名成了一系列 init.0 init.1 init.2 等等的函数。\n至此 LoadPackage() 的工作就完成了。\npkginit.MakeInit() 接下来终于来到了 pkginit 包的内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/gc/main.go#L59 // Main parses flags and Go source files specified in the command-line // arguments, type-checks the parsed Go package, compiles functions to machine // code, and finally writes the compiled package definition to disk. func Main(archInit func(*ssagen.ArchInfo)) { ... // Parse and typecheck input. noder.LoadPackage(flag.Args()) ... // Create \u0026#34;init\u0026#34; function for package-scope variable initialization // statements, if any. // // Note: This needs to happen early, before any optimizations. The // Go spec defines a precise order than initialization should be // carried out in, and even mundane optimizations like dead code // removal can skew the results (e.g., #43444). pkginit.MakeInit() ... // Build init task, if needed. if initTask := pkginit.Task(); initTask != nil { typecheck.Export(initTask) } ... 从注释也可以知道，在词法分析、语法分析以及类型检查和构造 IR 树的过程中，均未涉及代码优化。以下是 MakeInit() 的内容，关键部分使用中文进行了更详细的注释，可以对照相关方法的源码进行阅读。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // TODO(mdempsky): Move into noder, so that the types2-based frontends // can use Info.InitOrder instead. func MakeInit() { // Init 相关的处理只涉及全局声明（Package Level），依赖关系作为有向边来构建有向图，然后进行拓扑排序。 nf := initOrder(typecheck.Target.Decls) if len(nf) == 0 { return } // Make a function that contains all the initialization statements. base.Pos = nf[0].Pos() // prolog/epilog gets line number of first init stmt // 查找 init 符号，如果 Package 的全局符号中没有则创建；不用担心 init 符号已经被用户的 init 函数使用，因为 IR 树在生成过程中遇到 init 会重命名为 init.0 init.1 这样的格式，前面提到 g.generate() 的时候也有说明。 initializers := typecheck.Lookup(\u0026#34;init\u0026#34;) /* 用 init 符号声明一个新的函数，用于存放所有的初始化工作。具体实现是：此处在 IR 树中对应位置建立了新的 ONAME Node（ONAME 表示 var/func name），类型指定为 PFUNC，同时也将符号表中的 init 更新为 symFunc，表明这个符号是函数名；然后新建一个函数节点，将 ONAME Node 指向函数节点，最后将函数节点返回。 */ fn := typecheck.DeclFunc(initializers, nil, nil, nil) // 类型检查过程中生成了一个 InitTodoFunc，其作为全局初始化语句的临时上下文环境。现在将临时环境 InitTodoFunc 的内容转移到 fn。 for _, dcl := range typecheck.InitTodoFunc.Dcl { dcl.Curfn = fn } fn.Dcl = append(fn.Dcl, typecheck.InitTodoFunc.Dcl...) typecheck.InitTodoFunc.Dcl = nil // Suppress useless \u0026#34;can inline\u0026#34; diagnostics. // Init functions are only called dynamically. fn.SetInlinabilityChecked(true) // 配置函数体。 fn.Body = nf typecheck.FinishFuncBody() // 确定 fn 为函数节点 typecheck.Func(fn) // 在 fn 的内部上下文环境下检查函数体 ir.WithFunc(fn, func() { typecheck.Stmts(nf) }) // 把函数加入到 Package 的全局声明列表。 typecheck.Target.Decls = append(typecheck.Target.Decls, fn) // Prepend to Inits, so it runs first, before any user-declared init // functions. typecheck.Target.Inits = append([]*ir.Func{fn}, typecheck.Target.Inits...) if typecheck.InitTodoFunc.Dcl != nil { // We only generate temps using InitTodoFunc if there // are package-scope initialization statements, so // something\u0026#39;s weird if we get here. base.Fatalf(\u0026#34;InitTodoFunc still has declarations\u0026#34;) } typecheck.InitTodoFunc = nil } 旧版本中 MakeInit() 的工作是在 pkginit.Task() 中实现的，现在被抽取了出来，原因有以下几点。\n首先，MakeInit() 负责初始化函数的创建并插入 typecheck.Target.Inits，pkginit.Task() 得到了简化，毕竟这个初始化函数和其他用户定义的 init 实际上没有本质区别。\n其次，敏锐的同学可能发现了，类型检查的过程中，已经进行了一次 initOrder()，但只检查了循环依赖的问题；这次又 initOrder() 显得有些冗余。因此将这一部分从 Task() 中拆分出来，希望以后能够放到类型检查的过程中，避免重复的排序操作。当前抽离成了单独的函数但是还未并入类型检查，处于中间状态，可见不久后将会并入类型检查，注释中的 TODO 就是在说这个问题。\n最后，初始化函数如果在 Task() 中创建，则无法参与到类型检查结束到 Task() 开始这之间的优化过程，主要包括无效代码清理和内联优化。因此将其提前到类型检查结束后创建，这样就可以参与到优化过程中了。\npkginit.Task() 最后，终于来到了 init 处理的终点， pkginit.Task()。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/cmd/compile/internal/pkginit/init.go#L93 // Task makes and returns an initialization record for the package. // See runtime/proc.go:initTask for its layout. // The 3 tasks for initialization are: // 1. Initialize all of the packages the current package depends on. // 2. Initialize all the variables that have initializers. // 3. Run any init functions. func Task() *ir.Name { ... // Find imported packages with init tasks. // 这里可以看出 Package 最终的初始化任务被合并在了 .inittask 这个结构体中，因此对于引用的包才能这样进行查找，此处还检查了 .inittask 结构体是否合法。最终加入到 deps 数组。 for _, pkg := range typecheck.Target.Imports { n := typecheck.Resolve(ir.NewIdent(base.Pos, pkg.Lookup(\u0026#34;.inittask\u0026#34;))) if n.Op() == ir.ONONAME { continue } if n.Op() != ir.ONAME || n.(*ir.Name).Class != ir.PEXTERN { base.Fatalf(\u0026#34;bad inittask: %v\u0026#34;, n) } deps = append(deps, n.(*ir.Name).Linksym()) } ... // 如果开启了 Address Sanitizer，那么需要在创建一个 init 函数加入 typecheck.Target.Inits，用于初始化 ASan 相关的全局变量。 if base.Flag.ASan { ... // 可见这个 init 将会在最后执行 typecheck.Target.Inits = append(typecheck.Target.Inits, fnInit) } ... // Record user init functions. for _, fn := range typecheck.Target.Inits { // 只有处理 Package 全局变量的才叫 init，其它的都被重命名为了 init.0、init.1 等。 if fn.Sym().Name == \u0026#34;init\u0026#34; { // Synthetic init function for initialization of package-scope // variables. We can use staticinit to optimize away static // assignments. s := staticinit.Schedule{ Plans: make(map[ir.Node]*staticinit.Plan), Temps: make(map[ir.Node]*ir.Name), } for _, n := range fn.Body { s.StaticInit(n) } fn.Body = s.Out ir.WithFunc(fn, func() { typecheck.Stmts(fn.Body) }) if len(fn.Body) == 0 { fn.Body = []ir.Node{ir.NewBlockStmt(src.NoXPos, nil)} } } // Skip init functions with empty bodies. if len(fn.Body) == 1 { if stmt := fn.Body[0]; stmt.Op() == ir.OBLOCK \u0026amp;\u0026amp; len(stmt.(*ir.BlockStmt).List) == 0 { continue } } fns = append(fns, fn.Nname.Linksym()) } 最终 fns 数组保存了所有 init 函数；deps 数组保存了所有依赖的包的 .inittask 结构体。接下来合并构建自己 Package 的 .inittask。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // Make an .inittask structure. sym := typecheck.Lookup(\u0026#34;.inittask\u0026#34;) task := typecheck.NewName(sym) // 显然这个 .inittask 不是 uint8 类型的，只是为了占位，因此这里设置了一个 fake type。 task.SetType(types.Types[types.TUINT8]) // fake type task.Class = ir.PEXTERN sym.Def = task lsym := task.Linksym() ot := 0 // lsym.P = [0] ot = objw.Uintptr(lsym, ot, 0) // state: not initialized yet // lsym.P = [0, len(deps)] ot = objw.Uintptr(lsym, ot, uint64(len(deps))) // lsym.P = [0, len(deps), len(fns)] ot = objw.Uintptr(lsym, ot, uint64(len(fns))) // lsym.R = [newR(d)...] for _, d := range deps { ot = objw.SymPtr(lsym, ot, d, 0) } // lsym.R = [newR(d)..., newR(f)...] for _, f := range fns { ot = objw.SymPtr(lsym, ot, f, 0) } // An initTask has pointers, but none into the Go heap. // It\u0026#39;s not quite read only, the state field must be modifiable. // 此处说明这个 .inittask 符号是全局的，决定了最后在 object 文件中的位置区域。 objw.Global(lsym, int32(ot), obj.NOPTR) return task 在最后将其设置为导出的（Export），因为其符号名并非大写字母开头，但是要被其他包使用：\n1 2 3 4 // Build init task, if needed. if initTask := pkginit.Task(); initTask != nil { typecheck.Export(initTask) } 至此，Package 单元对于 init 的处理就结束了，最后 Package 被编译为带有 .inittask 表的 object 文件，这个表中包含了所有的 init.x 函数和依赖的包的 .inittask 结构体指针，要注意这里只知道符号之间的关系，其他包里 init 函数的具体实现是不知道的，需要在链接阶段处理。\n链接时，在拥有了所有的 .inittask 包含的具体函数相关信息后，链接器会将其按照依赖关系进行排序，生成一个具体的 mainInittasks 列表供 runtime 使用。此处不再展开这一部分，有兴趣的同学可以自行阅读链接器 inittask 部分的源码：src/cmd/link/internal/ld/inittask.go，最终 SymbolName 为 go:main.inittasks。\n最终链接生成可执行文件时，inittasks 的地址会给到 src/runtime/proc.go 的 runtime_inittasks 数组变量，然后在runtime.main 函数中被使用：\n1 2 3 4 5 6 // https://github.com/golang/go/blob/d8117459c513e048eb72f11988d5416110dff359/src/runtime/proc.go#L144 func main() { ... doInit(runtime_inittasks) // Must be before defer. ... } 最后回看一开始发现的现象：\n[现象]：a/b.go 和 a/c.go 的 init() 函数的执行顺序是按照文件名的字母顺序来的，将 a/b.go 改名后，其文件名顺序排在了 a/c.go 之后，最终 init() 执行也排在了之后。\n根源在于编译器在读取源文件时是按照文件系统文件名顺序读入，在处理时也是依文件次序处理的，也就是编译器遇到 init 和 import 的顺序都是由文件名顺序决定的。\n虽然有 initOrder() 的存在，但是它不会影响用户定义的 init() 的顺序\ninitOrder() 会处理 import 的依赖关系，因此最终各个 Package 的 init 顺序时根据依赖关系决定的。\n例如：\n1 2 // a1.go import \u0026#34;b\u0026#34; 1 2 // a2.go import \u0026#34;c\u0026#34; 1 2 // b.go import \u0026#34;c\u0026#34; 那么不管 a1.go 和 a2.go 的文件名顺序如何，package c 都会先于 package b 初始化，因为 b 依赖 c。\n","permalink":"https://xinrea.cn/posts/go-init/","summary":"本文中引用的源码均标注了 Golang 源码仓库链接，branch 为 release-branch.go1.21（本文在编写时 Go 1.21 还未正式发布，正式版可能会","title":"从 init 函数的顺序问题到 Go 编译器"},{"content":"在学习熟悉 CubismSDK 的时候，曾给轴伊Joi制作过一个简单的 Live2D 桌面宠物；由于是在官方样例的基础上进行的修改，因此程序主题通过 glew + glfw 来进行实现。由于桌面宠物的特殊性（需要尽可能减少对桌面操作的影响），可以说是必须实现异形窗口。这个异形窗口与一般的需求还不太一样：通常异形窗口是静态的，仅以一张图片作为底图，有很多种方法可以实现，其中一种便是用蒙版（Mask）来实现，但这种方式在桌面宠物这种场景下显得有点尴尬。\n对于用 OpenGL 动态渲染的桌面宠物来说，读取当前 Buffer 生成 Mask 是效率极低的。好在 Windows 下提供了 SetLayeredWindowAttributes(hwnd,RGB(0, 0, 0), 255, LWA_COLORKEY) 这一方法，直接进行键值抠图即可。但问题是其精度极低，渲染出的模型边缘会出现很明显的底色锯齿边缘。\n在 glfw 中，通过 glfwWindowHint(GLFW_TRANSPARENT_FRAMEBUFFER, GLFW_TRUE) 可实现窗口 Buffer 新增 Alpha 通道；配合 LWA_COLORKEY 即可实现无锯齿边缘的 OpenGL 渲染的即时异形窗口。\n然而最近在使用 Qt 对其重构的过程中，又遇到了异形窗口的这一问题。Qt 提供了两种使用 OpenGL 的方式，QOpenGLWindow 与 QOpenGLWidget；这两种方式在使用上几乎没有差异，可以很方便的互相转换。但在实现异形窗口的过程中遇到了问题。\n通过实践发现，QOpenGLWidget 通过设置 Qt::WA_TranslucentBackground 可以很简单的实现透明背景；但 LWA_COLORKEY 只对 WS_EX_LAYERED 样式的窗口生效；经过测试，QOpenGLWidget 单独作为窗口时，无法设置 WS_EX_LAYERED 样式，因此无法实现异形窗口。\nQOpenGLWindow 可以直接设置 WS_EX_LAYERED 样式，但无法设置透明背景（可使用 setFormat 添加 alpha 通道属性，但配合 LWA_COLORKEY 会显示异常）；因此需要自行实现 GLFW_TRANSPARENT_FRAMEBUFFER 的功能。\n通过阅读 glfw 源码，该设置相关的代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #define DWM_BB_ENABLE 0x00000001 #define DWM_BB_BLURREGION 0x00000002 typedef struct { DWORD dwFlags; BOOL fEnable; HRGN hRgnBlur; BOOL fTransitionOnMaximized; } DWM_BLURBEHIND; typedef HRESULT(WINAPI * PFN_DwmEnableBlurBehindWindow)(HWND,const DWM_BLURBEHIND*); void setTransparentBuffer(HWND hwnd) { auto dll = LoadLibraryA(\u0026#34;dwmapi.dll\u0026#34;); auto DwmEnableBlurBehindWindow = (PFN_DwmEnableBlurBehindWindow)GetProcAddress((HMODULE) dll, \u0026#34;DwmEnableBlurBehindWindow\u0026#34;); HRGN region = CreateRectRgn(0, 0, -1, -1); DWM_BLURBEHIND bb = {0}; bb.dwFlags = DWM_BB_ENABLE | DWM_BB_BLURREGION; bb.hRgnBlur = region; bb.fEnable = TRUE; DwmEnableBlurBehindWindow(hwnd, \u0026amp;bb); DeleteObject(region); } 最终使用 QOpenGLWindow，手动设置透明 FrameBuffer，然后设置 LWA_COLORKEY，实现了完美的 OpenGL 内容的异形窗口。\n","permalink":"https://xinrea.cn/posts/qt-opengl-semi-window/","summary":"在学习熟悉 CubismSDK 的时候，曾给轴伊Joi制作过一个简单的 Live2D 桌面宠物；由于是在官方样例的基础上进行的修改，因此程序主题通过 glew + glfw 来进行实现。由于桌面","title":"Qt OpenglWindow 异形窗口的实现"},{"content":"最近在开发的项目用到了 gRPC，并且要求使用证书进行双向认证。于是便生成了一个 CA 证书，并以此签名生成了服务端和客户端所需的各种证书，且在周五进行客户端服务端连接测试时一切正常。周末两天过去了，周一再进行测试时，连接出现了如下错误:\ntransport: authentication handshake failed: EOF\n一开始还以为是证书验证出了问题，对相关证书以及涉及到的代码进行了回退，然后进行测试，仍然出现该问题。后续经过排查，排除了证书出错的这一原因，最后莫名在重启电脑后恢复了正常。后来发现是电脑上安装的梯子导致了这一问题。该问题的产生涉及到的前置原因如下：\n由于办公网络环境较差，于是临时安装梯子，搭配手机热点进行开发工作 由于需要使用证书双向认证，在证书 SANs 中添加了域名 *.sample.com 由于证书的使用需验证域名，因此本地测试时，修改 /etc/hosts 文件将相关域名解析到了本地地址 127.0.0.1 测试用的域名匹配了代理规则 由于使用域名测试连接，匹配了代理的规则，导致本地测试的连接无法建立，出现了上述的问题。由于客户端和服务端均在本地进行测试，因此一开始并未考虑连接问题，但最终发现问题是经梯子代理导致无法建立连接。\n","permalink":"https://xinrea.cn/posts/about-grpc-connection/","summary":"最近在开发的项目用到了 gRPC，并且要求使用证书进行双向认证。于是便生成了一个 CA 证书，并以此签名生成了服务端和客户端所需的各种证书，且在周五","title":"一个 gRPC 的连接问题"},{"content":" 哔哩哔哩舰长私信助手 BiliMessenger Vue Electron\n哔哩哔哩自动化私信工具，主要用于舰长礼物链接私信分发，提供了舰长列表获取的便捷途径。\n最开始是使用 C# 来开发的 UWP 应用，并在微软应用商店上架与更新，后来使用 Vue + Electron 重构。\n桌面宠物轴伊 JPet Live2D Cubism SDK Live2D C++ OpenGL\n虚拟主播轴伊的可互动多功能 Live2D 桌面宠物。\n想着熟悉一下 Live2D SDK 开发，于是在官方样例的基础上开发了这个桌面宠物。最开始使用自己绘画\u0026amp;建模的一个轴伊Joi_Channel的团子形象 Live2D 模型，后来 轴伊Joi_Channel 提供了自身 Q 版差分立绘，逐渐改进完成了桌面宠物。\n简易提问箱 JAsk Svelte Golang\n简单的提问箱，支持话题、图片投稿等小功能，同时拥有一个简单的后台以管理投稿。\nBilibili 弹幕机 JLiverTool VanillaJS HTML Electron\nBilibili 弹幕机，除了常见的弹幕显示功能外，还支持礼物、醒目留言单独窗口显示，同时支持礼物记录本地保存管理。\n","permalink":"https://xinrea.cn/projects/","summary":"projects","title":"Projects"}]